{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/imgs/avatar.png","path":"imgs/avatar.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"a76d596c55651de6e16ae7eb0f7527f363afd0db","modified":1499321288000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1499321159000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1499321159000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1499321159000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1499321159000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1499321159000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1499321159000},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1499321159000},{"_id":"source/_posts/hexo-install.md","hash":"fd28a1acbbde7eed5e7d5b408a2453f388936049","modified":1499405530000},{"_id":"source/_posts/why-extends-is-evil.md","hash":"dc532d369deb409837a79b308d7e64c192b3ee56","modified":1499332120000},{"_id":"source/_posts/why-getter-and-setter-methods-are-evil.md","hash":"4a44c597f4d52ee50378f35c966026f7adb220c2","modified":1499331175000},{"_id":"source/archive/index.md","hash":"dfc3a87cdc34d54d971b7db466eeb8cabda46cc6","modified":1499324546000},{"_id":"source/categories/index.md","hash":"6f7a8ed18d8054e153fd97c82ce132a3669f3c43","modified":1499321535000},{"_id":"source/tags/index.md","hash":"fae6b8698e6a91d46af3647f2ed795c594993003","modified":1499325311000},{"_id":"themes/yilia/_config.yml","hash":"a25a79487fbfe1fdc32d6cd31f42262457b1126d","modified":1499331461000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1499321159000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1499321159000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1499321159000},{"_id":"themes/yilia/.git/index","hash":"0b1a0a084600840ee5037167e81dc5b8cd303fe6","modified":1499331486000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1499321159000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1499321159000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1499321159000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1499321154000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1499321159000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1499321159000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1499321159000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1499321159000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1499321159000},{"_id":"themes/yilia/.git/packed-refs","hash":"cf41ff42218453f57f86f8bf8a37ce6b19a31ad9","modified":1499321159000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1499321159000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1499321159000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1499321159000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1499321159000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1499321159000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1499321159000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1499321159000},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1499321159000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1499321159000},{"_id":"themes/yilia/source/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1499321159000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1499321159000},{"_id":"themes/yilia/source/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1499321159000},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1499321159000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1499321154000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1499321154000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1499321154000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"aceb08a3d44d4d463287a836ccf2b849fa60aa8c","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1499321159000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1499321159000},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1499321159000},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1499321159000},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1499321159000},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1499321159000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1499321159000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1499321159000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1499321159000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1499321159000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1499321159000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1499321159000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1499321159000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1499321159000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1499321159000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1499321159000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1499321159000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1499321159000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1499321159000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1499321159000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1499321159000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1499321159000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1499321159000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1499321159000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1499321159000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1499321159000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1499321159000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1499321159000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1499321159000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1499321159000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1499321159000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1499321159000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1499321159000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1499321159000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1499321159000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1499321159000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1499321159000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1499321159000},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1499321159000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1499321159000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1499321159000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1499321159000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1499321159000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1499321159000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1499321159000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1499321159000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1499321159000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"597a0d14c701a189e5d74eaa70341e78e3ad7c80","modified":1499321159000},{"_id":"themes/yilia/.git/objects/pack/pack-5a3add7776160ec34c0e932a8c6526509cd30af3.idx","hash":"71511774a41d8ec6e5dd458e0dea8687d2233dd0","modified":1499321158000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1499321159000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1499321159000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1499321159000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1499321159000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1499321159000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1499321159000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1499321159000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1499321159000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1499321159000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1499321159000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1499321159000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1499321159000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1499321159000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1499321159000},{"_id":"source/imgs/avatar.png","hash":"10807303aca50409317a55fa84c6644a8743e494","modified":1499309607000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"aceb08a3d44d4d463287a836ccf2b849fa60aa8c","modified":1499321159000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1499321159000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"aceb08a3d44d4d463287a836ccf2b849fa60aa8c","modified":1499321159000},{"_id":"source/_posts/hexo-install/helloworld.png","hash":"736f51ae57377b26430a6d02e357aedf98463a34","modified":1499405026000},{"_id":"themes/yilia/.git/objects/pack/pack-5a3add7776160ec34c0e932a8c6526509cd30af3.pack","hash":"bc1853297e6fe1d96ce54c9abc51ef83972ff9a7","modified":1499321158000},{"_id":"public/content.json","hash":"e0c0bf0812dcafef12e44d8da6bc9ec45fead143","modified":1499405342439},{"_id":"public/archive/index.html","hash":"83f440b87de1586fc8d80c16dcdaea166f135888","modified":1499405342563},{"_id":"public/categories/index.html","hash":"d2aafc439dbc946fa681ff5c0dbbea088dfefea8","modified":1499405342584},{"_id":"public/tags/index.html","hash":"8b5d2eea7364124b1181ea3026a171bc7f7b0aa0","modified":1499405342588},{"_id":"public/2017/01/10/why-getter-and-setter-methods-are-evil/index.html","hash":"3e6a976d0996c4c9f6a2c122c5dd123285f2ef99","modified":1499405342589},{"_id":"public/archives/index.html","hash":"c42b065b52df1f07c6888d0901a4891a0546cfb5","modified":1499405342589},{"_id":"public/archives/2017/index.html","hash":"7288bb5bec315d7823abf5f62901db4f5dbbb767","modified":1499405342589},{"_id":"public/2017/01/06/why-extends-is-evil/index.html","hash":"5eebd0a7f589de420f1c9c7e1d40e22e641e40a1","modified":1499405342589},{"_id":"public/archives/2017/01/index.html","hash":"8c53ac0c07f387663cafabda381601be5b277ab4","modified":1499405342589},{"_id":"public/2017/01/04/hexo-install/index.html","hash":"f72eb26443c0a74a455d56ae81e980cd05423a6a","modified":1499405535750},{"_id":"public/categories/Java/index.html","hash":"4ea67ebe0183d8ad2af541e8c92f6171aa034eca","modified":1499405342589},{"_id":"public/categories/hexo/index.html","hash":"ecce8dd8609c24949e21d31a4914e9cae84eba6d","modified":1499405342590},{"_id":"public/index.html","hash":"879129eef867f47950e7ecad614ec6a506faab61","modified":1499405535750},{"_id":"public/tags/Java/index.html","hash":"2eb4a596ee7d489e376c2f79437531a237eb4015","modified":1499405342591},{"_id":"public/tags/安装/index.html","hash":"79d10e072d4640d574ad241a5b9d1e41044114a5","modified":1499405342591},{"_id":"public/tags/翻译/index.html","hash":"c0c6758948fd774529012600eee6263ed7764109","modified":1499405342591},{"_id":"public/tags/hexo/index.html","hash":"912592ad5ece715ae46e5e34e8009a3f4c50251b","modified":1499405342595},{"_id":"public/tags/存储器/index.html","hash":"e4fcd15f130dcc3224e607cf765512a7cb6334a3","modified":1499405342595},{"_id":"public/tags/getter/index.html","hash":"a81510fb0142c460ae53c60f8d23c0da14b9dccb","modified":1499405342595},{"_id":"public/tags/setter/index.html","hash":"7438b90c445dcb3e5aa0949c6b0a881dbca4c2ba","modified":1499405342595},{"_id":"public/tags/继承/index.html","hash":"01dde2f3692fbf07f9fe456c427ecb2453e55750","modified":1499405342595},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1499405342598},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1499405342598},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1499405342598},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1499405342598},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1499405342598},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1499405342598},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1499405342598},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1499405342598},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1499405342598},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1499405342602},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1499405342602},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1499405342602},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1499405342603},{"_id":"public/imgs/avatar.png","hash":"10807303aca50409317a55fa84c6644a8743e494","modified":1499405342606},{"_id":"public/2017/01/04/hexo-install/helloworld.png","hash":"736f51ae57377b26430a6d02e357aedf98463a34","modified":1499405342608}],"Category":[{"name":"hexo","_id":"cj4tf869c00046b6n71nko5xd"},{"name":"Java","_id":"cj4tf869j00086b6nf55bi9tj"}],"Data":[],"Page":[{"title":"archive","date":"2017-07-06T07:02:26.000Z","_content":"","source":"archive/index.md","raw":"---\ntitle: archive\ndate: 2017-07-06 15:02:26\n---\n","updated":"2017-07-06T07:02:26.000Z","path":"archive/index.html","comments":1,"layout":"page","_id":"cj4tf869800016b6n019sjdwh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-07-06T06:12:15.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-07-06 14:12:15\n---\n","updated":"2017-07-06T06:12:15.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj4tf869b00036b6nkwhoxpem","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-07-06T06:12:08.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-07-06 14:12:08\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-07-06T07:15:11.000Z","path":"tags/index.html","layout":"page","_id":"cj4tf869h00076b6nx91rq5a2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Mac上搭建基于Hexo+Github的Blog","date":"2017-01-04T02:32:42.000Z","_content":"\n　　听人说资深程序员要没自己的blog都不好意思跟人打招呼，为了出去好zhuangB，参考一些文章，花了大半天搭建了基于Hexo+Github的Blog。\n主要参考了[这篇文章](http://www.cnblogs.com/MuYunyun/p/5927491.html)。\n![logo](hexo-install/helloworld.png)\n\n## 准备工作\n　　Hexo基于NodeJs所以先需要安装NodeJS，可以去[官网]（https://nodejs.org/en/）下载安装，或者使用brew进行安装。还需要在GitHub上创建仓库以发布Blog。  \n<!--more-->\n### 安装NodeJS\n#### 安装brew\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n#### 卸载node\n　　如果已经安装了旧版本NodeJS可以先卸载，Hexo的某些插件可能需要新版本的node。\n \n\t清理brew的link\n\t$ brew cleanup\n\t删除node文件，完全卸载node和npm\n\tsudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*}\n\t或者是\n\tsudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp /opt/local/bin/node opt/local/include/node /opt/local/lib/node_modules\n\t或者是下面这样：\n\t1. 在/usr/local/lib目录下，删除任何与node和 node_modules有关的目录；\n\t2. 在/usr/local/include 目录下，删除任何与node 和node_modules有关的目录；\n\t3. 如果你是通过**brew install node**安装的node，则在终端执行**brew uninstall node** ，并在home目录下查找 **local** 或**lib** 或 **include**文件夹，删除任何与**node** 和 **node_modules**有关的目录；\n\t4. 在**/usr/local/bin**目录下，删除任何与 **node** 执行文件；\n\t5. 最后下载 **nvm** ，跟随它的介绍安装node。当然，你也可以通过**npm**来安装最新版本的Node。\n\n#### brew安装node\n1. 首先更新brew，使其在最新版本，代码如下：  \n `$ brew update`  \n\n2. 确保brew是安全可靠的，代码如下：  \n `$ brew doctor`  \n   如果诊断有问题可以一一解决  \n\n3. 将brew的位置添加到$PATH环境变量中，并保存bash或者profile文件；  \n   `export PATH=\"/usr/local/bin:$PATH\"`\n\n4. 通过brew安装node和npm  \n`brew link node`  \n`brew uninstall node`  \n`brew install node`\n\n5. 查看安装版本  \n`node -v`  \n`npm -v`\n\n### 创建远程仓库\n　　登录Github帐号，新建仓库，用于blog的发布，名为`用户名.github.io`固定写法。  \n　　最好再创建一个仓库用于备份本地blog文件\n\n## 安装Hexo\n　　参考[官网教程](https://hexo.io/zh-cn/docs/index.html)安装Hexo，执行如下命令：  \n　　`$ sudo npm install -g hexo` \n\t\n\tHexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n\n　　创建一个blog目录，用于存放本地文件：  \n　　`mkdir blog`  \n　　`cd blog`  \n　　在创建目录下初始化,并安装hexo blog文件：  \n　　`hexo init`  \n　　`npm install`  \n　　hexo自带一个测试服务器，可以在正式发布钱进行预览：\n　　`hexo s`  \n　　此时，浏览器中打开网址http://localhost:4000，能看到初始页面\n![logo](hexo-install/helloworld.png)","source":"_posts/hexo-install.md","raw":"---\ntitle: Mac上搭建基于Hexo+Github的Blog\ndate: 2017-01-04 10:32:42\ntags:\n  - hexo\n  - 安装\ncategories: hexo\n\n---\n\n　　听人说资深程序员要没自己的blog都不好意思跟人打招呼，为了出去好zhuangB，参考一些文章，花了大半天搭建了基于Hexo+Github的Blog。\n主要参考了[这篇文章](http://www.cnblogs.com/MuYunyun/p/5927491.html)。\n![logo](hexo-install/helloworld.png)\n\n## 准备工作\n　　Hexo基于NodeJs所以先需要安装NodeJS，可以去[官网]（https://nodejs.org/en/）下载安装，或者使用brew进行安装。还需要在GitHub上创建仓库以发布Blog。  \n<!--more-->\n### 安装NodeJS\n#### 安装brew\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n#### 卸载node\n　　如果已经安装了旧版本NodeJS可以先卸载，Hexo的某些插件可能需要新版本的node。\n \n\t清理brew的link\n\t$ brew cleanup\n\t删除node文件，完全卸载node和npm\n\tsudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*}\n\t或者是\n\tsudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp /opt/local/bin/node opt/local/include/node /opt/local/lib/node_modules\n\t或者是下面这样：\n\t1. 在/usr/local/lib目录下，删除任何与node和 node_modules有关的目录；\n\t2. 在/usr/local/include 目录下，删除任何与node 和node_modules有关的目录；\n\t3. 如果你是通过**brew install node**安装的node，则在终端执行**brew uninstall node** ，并在home目录下查找 **local** 或**lib** 或 **include**文件夹，删除任何与**node** 和 **node_modules**有关的目录；\n\t4. 在**/usr/local/bin**目录下，删除任何与 **node** 执行文件；\n\t5. 最后下载 **nvm** ，跟随它的介绍安装node。当然，你也可以通过**npm**来安装最新版本的Node。\n\n#### brew安装node\n1. 首先更新brew，使其在最新版本，代码如下：  \n `$ brew update`  \n\n2. 确保brew是安全可靠的，代码如下：  \n `$ brew doctor`  \n   如果诊断有问题可以一一解决  \n\n3. 将brew的位置添加到$PATH环境变量中，并保存bash或者profile文件；  \n   `export PATH=\"/usr/local/bin:$PATH\"`\n\n4. 通过brew安装node和npm  \n`brew link node`  \n`brew uninstall node`  \n`brew install node`\n\n5. 查看安装版本  \n`node -v`  \n`npm -v`\n\n### 创建远程仓库\n　　登录Github帐号，新建仓库，用于blog的发布，名为`用户名.github.io`固定写法。  \n　　最好再创建一个仓库用于备份本地blog文件\n\n## 安装Hexo\n　　参考[官网教程](https://hexo.io/zh-cn/docs/index.html)安装Hexo，执行如下命令：  \n　　`$ sudo npm install -g hexo` \n\t\n\tHexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n\n　　创建一个blog目录，用于存放本地文件：  \n　　`mkdir blog`  \n　　`cd blog`  \n　　在创建目录下初始化,并安装hexo blog文件：  \n　　`hexo init`  \n　　`npm install`  \n　　hexo自带一个测试服务器，可以在正式发布钱进行预览：\n　　`hexo s`  \n　　此时，浏览器中打开网址http://localhost:4000，能看到初始页面\n![logo](hexo-install/helloworld.png)","slug":"hexo-install","published":1,"updated":"2017-07-07T05:32:10.000Z","_id":"cj4tf869400006b6n2soqk5an","comments":1,"layout":"post","photos":[],"link":"","content":"<p>　　听人说资深程序员要没自己的blog都不好意思跟人打招呼，为了出去好zhuangB，参考一些文章，花了大半天搭建了基于Hexo+Github的Blog。<br>主要参考了<a href=\"http://www.cnblogs.com/MuYunyun/p/5927491.html\" target=\"_blank\" rel=\"external\">这篇文章</a>。<br><img src=\"/2017/01/04/hexo-install/helloworld.png\" alt=\"logo\"></p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>　　Hexo基于NodeJs所以先需要安装NodeJS，可以去[官网]（<a href=\"https://nodejs.org/en/）下载安装，或者使用brew进行安装。还需要在GitHub上创建仓库以发布Blog。\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/）下载安装，或者使用brew进行安装。还需要在GitHub上创建仓库以发布Blog。</a><br><a id=\"more\"></a></p>\n<h3 id=\"安装NodeJS\"><a href=\"#安装NodeJS\" class=\"headerlink\" title=\"安装NodeJS\"></a>安装NodeJS</h3><h4 id=\"安装brew\"><a href=\"#安装brew\" class=\"headerlink\" title=\"安装brew\"></a>安装brew</h4><p>ruby -e “$(curl -fsSL <a href=\"https://raw.githubusercontent.com/Homebrew/install/master/install\" target=\"_blank\" rel=\"external\">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>\n<h4 id=\"卸载node\"><a href=\"#卸载node\" class=\"headerlink\" title=\"卸载node\"></a>卸载node</h4><p>　　如果已经安装了旧版本NodeJS可以先卸载，Hexo的某些插件可能需要新版本的node。</p>\n<pre><code>清理brew的link\n$ brew cleanup\n删除node文件，完全卸载node和npm\nsudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*}\n或者是\nsudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp /opt/local/bin/node opt/local/include/node /opt/local/lib/node_modules\n或者是下面这样：\n1. 在/usr/local/lib目录下，删除任何与node和 node_modules有关的目录；\n2. 在/usr/local/include 目录下，删除任何与node 和node_modules有关的目录；\n3. 如果你是通过**brew install node**安装的node，则在终端执行**brew uninstall node** ，并在home目录下查找 **local** 或**lib** 或 **include**文件夹，删除任何与**node** 和 **node_modules**有关的目录；\n4. 在**/usr/local/bin**目录下，删除任何与 **node** 执行文件；\n5. 最后下载 **nvm** ，跟随它的介绍安装node。当然，你也可以通过**npm**来安装最新版本的Node。\n</code></pre><h4 id=\"brew安装node\"><a href=\"#brew安装node\" class=\"headerlink\" title=\"brew安装node\"></a>brew安装node</h4><ol>\n<li><p>首先更新brew，使其在最新版本，代码如下：<br><code>$ brew update</code>  </p>\n</li>\n<li><p>确保brew是安全可靠的，代码如下：<br><code>$ brew doctor</code><br>如果诊断有问题可以一一解决  </p>\n</li>\n<li><p>将brew的位置添加到$PATH环境变量中，并保存bash或者profile文件；<br><code>export PATH=&quot;/usr/local/bin:$PATH&quot;</code></p>\n</li>\n<li><p>通过brew安装node和npm<br><code>brew link node</code><br><code>brew uninstall node</code><br><code>brew install node</code></p>\n</li>\n<li><p>查看安装版本<br><code>node -v</code><br><code>npm -v</code></p>\n</li>\n</ol>\n<h3 id=\"创建远程仓库\"><a href=\"#创建远程仓库\" class=\"headerlink\" title=\"创建远程仓库\"></a>创建远程仓库</h3><p>　　登录Github帐号，新建仓库，用于blog的发布，名为<code>用户名.github.io</code>固定写法。<br>　　最好再创建一个仓库用于备份本地blog文件</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>　　参考<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">官网教程</a>安装Hexo，执行如下命令：<br>　　<code>$ sudo npm install -g hexo</code> </p>\n<pre><code>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n</code></pre><p>　　创建一个blog目录，用于存放本地文件：<br>　　<code>mkdir blog</code><br>　　<code>cd blog</code><br>　　在创建目录下初始化,并安装hexo blog文件：<br>　　<code>hexo init</code><br>　　<code>npm install</code><br>　　hexo自带一个测试服务器，可以在正式发布钱进行预览：<br>　　<code>hexo s</code><br>　　此时，浏览器中打开网址<a href=\"http://localhost:4000，能看到初始页面\" target=\"_blank\" rel=\"external\">http://localhost:4000，能看到初始页面</a><br><img src=\"/2017/01/04/hexo-install/helloworld.png\" alt=\"logo\"></p>\n","site":{"data":{}},"excerpt":"<p>　　听人说资深程序员要没自己的blog都不好意思跟人打招呼，为了出去好zhuangB，参考一些文章，花了大半天搭建了基于Hexo+Github的Blog。<br>主要参考了<a href=\"http://www.cnblogs.com/MuYunyun/p/5927491.html\" target=\"_blank\" rel=\"external\">这篇文章</a>。<br><img src=\"/2017/01/04/hexo-install/helloworld.png\" alt=\"logo\"></p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>　　Hexo基于NodeJs所以先需要安装NodeJS，可以去[官网]（<a href=\"https://nodejs.org/en/）下载安装，或者使用brew进行安装。还需要在GitHub上创建仓库以发布Blog。\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/）下载安装，或者使用brew进行安装。还需要在GitHub上创建仓库以发布Blog。</a><br></p>","more":"<p></p>\n<h3 id=\"安装NodeJS\"><a href=\"#安装NodeJS\" class=\"headerlink\" title=\"安装NodeJS\"></a>安装NodeJS</h3><h4 id=\"安装brew\"><a href=\"#安装brew\" class=\"headerlink\" title=\"安装brew\"></a>安装brew</h4><p>ruby -e “$(curl -fsSL <a href=\"https://raw.githubusercontent.com/Homebrew/install/master/install\" target=\"_blank\" rel=\"external\">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>\n<h4 id=\"卸载node\"><a href=\"#卸载node\" class=\"headerlink\" title=\"卸载node\"></a>卸载node</h4><p>　　如果已经安装了旧版本NodeJS可以先卸载，Hexo的某些插件可能需要新版本的node。</p>\n<pre><code>清理brew的link\n$ brew cleanup\n删除node文件，完全卸载node和npm\nsudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*}\n或者是\nsudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp /opt/local/bin/node opt/local/include/node /opt/local/lib/node_modules\n或者是下面这样：\n1. 在/usr/local/lib目录下，删除任何与node和 node_modules有关的目录；\n2. 在/usr/local/include 目录下，删除任何与node 和node_modules有关的目录；\n3. 如果你是通过**brew install node**安装的node，则在终端执行**brew uninstall node** ，并在home目录下查找 **local** 或**lib** 或 **include**文件夹，删除任何与**node** 和 **node_modules**有关的目录；\n4. 在**/usr/local/bin**目录下，删除任何与 **node** 执行文件；\n5. 最后下载 **nvm** ，跟随它的介绍安装node。当然，你也可以通过**npm**来安装最新版本的Node。\n</code></pre><h4 id=\"brew安装node\"><a href=\"#brew安装node\" class=\"headerlink\" title=\"brew安装node\"></a>brew安装node</h4><ol>\n<li><p>首先更新brew，使其在最新版本，代码如下：<br><code>$ brew update</code>  </p>\n</li>\n<li><p>确保brew是安全可靠的，代码如下：<br><code>$ brew doctor</code><br>如果诊断有问题可以一一解决  </p>\n</li>\n<li><p>将brew的位置添加到$PATH环境变量中，并保存bash或者profile文件；<br><code>export PATH=&quot;/usr/local/bin:$PATH&quot;</code></p>\n</li>\n<li><p>通过brew安装node和npm<br><code>brew link node</code><br><code>brew uninstall node</code><br><code>brew install node</code></p>\n</li>\n<li><p>查看安装版本<br><code>node -v</code><br><code>npm -v</code></p>\n</li>\n</ol>\n<h3 id=\"创建远程仓库\"><a href=\"#创建远程仓库\" class=\"headerlink\" title=\"创建远程仓库\"></a>创建远程仓库</h3><p>　　登录Github帐号，新建仓库，用于blog的发布，名为<code>用户名.github.io</code>固定写法。<br>　　最好再创建一个仓库用于备份本地blog文件</p>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>　　参考<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">官网教程</a>安装Hexo，执行如下命令：<br>　　<code>$ sudo npm install -g hexo</code> </p>\n<pre><code>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。\n</code></pre><p>　　创建一个blog目录，用于存放本地文件：<br>　　<code>mkdir blog</code><br>　　<code>cd blog</code><br>　　在创建目录下初始化,并安装hexo blog文件：<br>　　<code>hexo init</code><br>　　<code>npm install</code><br>　　hexo自带一个测试服务器，可以在正式发布钱进行预览：<br>　　<code>hexo s</code><br>　　此时，浏览器中打开网址<a href=\"http://localhost:4000，能看到初始页面\" target=\"_blank\" rel=\"external\">http://localhost:4000，能看到初始页面</a><br><img src=\"/2017/01/04/hexo-install/helloworld.png\" alt=\"logo\"></p>"},{"title":"为什么extends是魔鬼","date":"2017-01-06T08:02:08.000Z","_content":"# 为什么extends是魔鬼\n**_通过使用接口替换具体的base类来改进你的代码_**\n\n[原文地址](http://www.javaworld.com/javaworld/jw-08-2003/jw-0801-toolbox.html)\n\n# 前言\n　　`extends`关键字是魔鬼。可能还没有达到Charles Manson的程度，但是也已经达到了需要敬而远之的地步。四人帮的设计模式一书详尽的讨论了使用接口继承(`implements`)替代实现继承(`extends`)。\n　　\n　　好的设计者基于接口编写代码而不是依靠具体的基础类。这篇文章阐述了为什么设计者有这种古怪习惯，以及介绍一些基于接口的编程基础。\n\n\n## 接口与类\n\n　　一次我去参加一个Java用户小组会议，当时Java的发明者James Gosling是主讲人。在那个另人难忘的提问环节，有人问他：“如果给你个机会重新设计JAVA，你会做些什么改变？”。他回答道：“我会去除类”。在哄堂大笑之后他解释到从本质上问题不出在类本身而出在实现继承关系上。(`extends`关系)。接口继承（`implements`关系）是更好的。你应该尽可能的避免实现继承关系无论在何时。\n<!--more-->\n## 失去灵活性\n　　为什么要避免实现继承关系？首当其冲的问题是明确使用具体的类名会把你与特定的实现捆绑在一起，这给以后的变更带来了不必要的麻烦。\n\n　　设计和开发并行是现代敏捷开发理念的核心观点。在完全设计好程序之前就已经开始着手开发了。这种技术悍然无视传统理论中开发之前必须有完备设计的观念，但是很多的成功项目都证明比起传统途径来你可以使用敏捷理念来更快速更有性价比的开发高质量代码。然而，在并行开发的理念中灵活性是核心理念。你不得不使你的代码能够做到只需很小的改动就能把新需求融合到现有的代码中去。\n\n　　只实现明确需要的特性而不是实现可能需要的特性并且包容变化。没有这种灵活性，并行开发是不可能的。\n\n　　面向接口编程是灵活结构的核心。为了说清为什么，让我们来看看当不用的时候会发生什么。思考以下代码\n\n\tf()\n\t{   LinkedList list = new LinkedList();\n\t\t//...\n\t\tg( list );\n\t}\n\tg( LinkedList list )\n\t{\n\t\tlist.add( ... );\n\t\tg2( list )\n\t}\n\n　　现在设想一个新的快速查找的需求出现了，因此LinkedList不能解决问题。你需要使用HashSet取代。在现在的代码里，这个改动不局限于一处因为你必须同事改动f函数和g函数以及所有像g函数那样获取这个list的方法。\n\n　　重写代码如下:\n\n\tf()\n\t{   Collection list = new LinkedList();\n\t\t//...\n\t\tg( list );\n\t}\n\tg( Collection list )\n\t{\n\t\tlist.add( ... );\n\t\tg2( list )\n\t}\n　　重构使得只需要简单的把new LinkedList( )替换成new HashSet( ) 酒可以把Link list改成hash表。就是这么神奇，不要其他任何改动。\n\n　　另一个例子，比较下以下两段代码：\n\t\n\tf()\n\t{   Collection c = new HashSet();\n\t\t//...\n\t\tg( c );\n\t}\n\tg( Collection c )\n\t{\n\t\tfor( Iterator i = c.iterator(); i.hasNext() ;)\n\t\tdo_something_with( i.next() );\n\t}\n\tf2()\n\t{   Collection c = new HashSet();\n\t\t//...\n\t\tg2( c.iterator() );\n\t}\n\tg2( Iterator i )\n\t{   while( i.hasNext() ;)\n\t\tdo_something_with( i.next() );\n\t}\n　　g2函数现在不仅可以遍历Collection的衍生对象也可以遍历像Map这种键值列表。事实上，你能使用迭代器生成数据而不是遍历集合。你可以使用迭代器为程序从测试框架或者文件中收集信息。这里面有巨大的灵活性\n\n## 耦合\n　　实现继承的一个更关键的问题时耦合——一部分模块对另一部分不恰当的依赖。强耦合带来麻烦最经典的例子是全局变量。比如你改变了全局变量的类型，所有使用这个变量（也就是耦合于此变量）的所有函数都会收到影响，因此所有的代码都必须被检查、修改、重新测试。进一步，所有函数都因为使用了这个变量而被彼此耦合在一起。如果一个方法在不恰当的时间修改了变量的值那么它就可能错误的影响了其他函数的表现。这个问题在多线程的程序中特别的可怕。\n\n　　作为一个设计这，你应该致力于构建最小的耦合关系。你不能完全消除耦合因为一个类对象调用另一个对象的方法是松耦合的一种形式。一个没有耦合的程序是天方夜谭。虽然如此，你只要闭着眼睛去遵循OO的戒律（最重要的是一个类的实现应该对调用的类完全隐藏）就能把耦合降到最低。比如类实例变量（不是常量的成员字段）应该始终是私有的。句号！毫无例外！永远！（你能偶尔有效地使用`protected`方法，但是`protected`实例变量是被唾弃的）你永远不应该使用get/set方法因为相同的原因——它只是用一个非常复杂的方法使成员变成了共有的（虽然返回成熟对象的存取方法而不是基本类型值在某些情况下是合理的，比如当返回的对象在设计中是一个关键的抽象）\n\n　　我不是在这卖弄学问。我已经找到了一条途径去解决严格的OO方法、快速开发和易维护性之间的矛盾。每当我违反一条OO的核心原则类似实现隐藏，最终否导致我必须重写那些代码（最常见的原因是不能进行debug）。我没有时间重写代码，所以我遵循这些规则。我的顾虑都是很实际的而不是为了完美而完美。\n\n## 脆弱的基础类问题\n　　现在，让我们把耦合的概念应用到继承.在一个使用`extends`的实现继承系统里,衍生类与基础类有着非常紧密的耦合。这种密切的联系是不可取的。设计者给这种行为起了个绰号“脆弱的基础类问题”。基础类被认为是脆弱的因为你能用一种看似看全的方法修改技术类，但是这个新的行为当被衍生类继承后可能导致衍生类出现故障。你不能简单说一个基础类是否安全仅仅是通过单独测试基础类的方法。你也必须测试所有的衍生类。进一步，你必须检查所有使用基础类和衍生类对象的代码，因为这些代码可能被新的行为破坏。一个简单的关键基础类的变动可能导致整个程序无法工作。\n\n　　让我们一起检查脆弱的基础类和基础类耦合问题。下面的类继承了Java的ArrayList类并添加一个类似于栈的新行为：\n\n\tclass Stack extends ArrayList\n\t{   private int stack_pointer = 0;\n\t\tpublic void push( Object article )\n\t\t{   add( stack_pointer++, article );\n\t\t}\n\t\tpublic Object pop()\n\t\t{   return remove( --stack_pointer );\n\t\t}\n\t\tpublic void push_many( Object[] articles )\n\t\t{   for( int i = 0; i < articles.length; ++i )\n\t\t\tpush( articles[i] );\n\t\t}\n\t}\n　　如此之简单的类都会有问题。考虑当一个用户利用继承并使用`ArrayList`的`clear()`方法去清空栈：\n\n\tStack a_stack = new Stack();\n\ta_stack.push(\"1\");\n\ta_stack.push(\"2\");\n\ta_stack.clear();\n　　代码成功编译，但因为基础类不知道`stack_pointer`的存在，这个栈对象现在是没有定义的状态。下一个调用`push()`你压入新的元素在序列2处（`stack_pointer`当前值），因此栈事实上有3个元素，底部的两个变成了脏数据。（Java的栈类有相同的问题，不要使用他）。\n\n　　一个解决这个方法继承不当的问题是为栈重写所有的`ArrayList`方法使其能修改队列状态，重写那些方法去正确操作`stack_pointer`或者抛出异常。（`removeRange()`方法是一个很好的抛出异常的候选者）\n\n　　这个方法有两个劣势。首先，你重写了所有方法，基础类实际上变成了一个接口，不是一个类。既然你不使用任何继承方法那么实现继承还有任何意义吗？其次，一个更重要的原因，你不想栈支持所有的`ArrayList`方法。例如烦人的`removeRange`方法就毫无用处。对于继承来的无用的方法唯一可行的办法是抛出异常，因为它应该永远不会被调用。这种方式实际上把一个编译错误变成了运行时错误。非常不好。如果一个方法不是简单因为未被声明而被编译器检查出方法未找到错误。如果方法仅仅是抛出异常，那么你在程序运行钱都不会发现调用错误。\n\n　　一个更好的基础类解决方案是封装数据机构代替使用继承。下面是一个新的改进过的栈版本\n\n\tclass Stack\n\t{   private int stack_pointer = 0;\n\t\tprivate ArrayList the_data = new ArrayList();\n\t\tpublic void push( Object article )\n\t\t{   the_data.add( stack_pointer++, article );\n\t\t}\n\t\tpublic Object pop()\n\t\t{   return the_data.remove( --stack_pointer );\n\t\t}\n\t\tpublic void push_many( Object[] articles )\n\t\t{   for( int i = 0; i < o.length; ++i )\n\t\t\tpush( articles[i] );\n\t\t}\n\t}\n　　到目前为止看起来还不错，但是考虑考虑脆弱的基础类问题。让我们看下当你想创建一个栈的变体用来跟踪确定时间端内栈的最大值，一个可能的实现如下所示：\n\n\tclass Monitorable_stack extends Stack\n\t{\n\t\tprivate int high_water_mark = 0;\n\t\tprivate int current_size;\n\t\tpublic void push( Object article )\n\t\t{   if( ++current_size > high_water_mark )\n\t\t\thigh_water_mark = current_size;\n\t\t\tsuper.push(article);\n\t\t}\n\t\tpublic Object pop()\n\t\t{   --current_size;\n\t\t\treturn super.pop();\n\t\t}\n\t\tpublic int maximum_size_so_far()\n\t\t{   return high_water_mark;\n\t\t}\n\t}\n　　这个新对象运行正常，至少暂时是这样，不幸的是这段代码利用了一个事实那就是`push_many()`是通过调用`push()`来完成它的工作的。其实，这些细节似乎不是一个坏的选择。这简化了代码，你通过重载`push()`版本来实现，即使当`Monitorable_stact`通过获得一个`stack`引用来实现的，所以`high_water_mark`正确的更新了。\n　　\n　　在一个阳光明媚的日子，某人可能跑了一个性能测试并且注意到Stack类在被大量使用时运行效率不太理想。你决定重写Stack并且放弃使用ArrayList，因此你提高了Stack类的性能。下面是新类的部分核心代码：\n\n\tclass Stack\n\t{   private int stack_pointer = -1;\n\t\tprivate Object[] stack = new Object[1000];\n\t\tpublic void push( Object article )\n\t\t{   assert stack_pointer < stack.length;\n\t\t\tstack[ ++stack_pointer ] = article;\n\t\t}\n\t\tpublic Object pop()\n\t\t{   assert stack_pointer >= 0;\n\t\t\treturn stack[ stack_pointer-- ];\n\t\t}\n\t\tpublic void push_many( Object[] articles )\n\t\t{   assert (stack_pointer + articles.length) < stack.length;\n\t\t\tSystem.arraycopy(articles, 0, stack, stack_pointer+1,\n\t\t\t\t\t\t\t\tarticles.length);\n\t\t\tstack_pointer += articles.length;\n\t\t}\n\t}\n　　注意`push_many()`不再重复调用`push( )`而是使用了块转移。新的栈版本工作的很好；事实上，它比前个版本要更好。不幸的是，`Monitorable_stack`衍生类将不再工作，因为当`push_many`被调用是它不能正确的跟踪栈的使用情况。（衍生类的push版本不再被`push_many`调用，所以`push_many`也不再更新high_water_mark）。Stack就是脆弱的基础类。事实证明，通过谨慎的做法来解决这些问题几乎是不可能的。\n　　\n　　记住，如果你使用接口继承就不会有这些问题，因为没有继承的方法会对你产生不利的影响。如果Stack是接口，通过同时实现`Simple_stack`和`Monitorable_stack`来使用,代码会变得更健壮。\n　　\n　　我在清单0.1中提供一个基于接口的解决方案。这个解决方案和实现继承方案有相同的灵活性：你能在Stack抽象基础上构建你的代码为不用担心你究竟是在操作哪种具体类型的栈。既然两个实现类必须提供公共接口中的所有东西的实现版本，因此很难出现前面所讲的问题。虽然不使用基础类我仍然能获得类似的好处，因为我使用了封装而不是派生。另一方面，在封装类中我不得不使用没有价值的访问方法去访问默认的实现。(比如在第41行`Monitorable_Stack.push(…）`不得不在`Simp_stack`中调用`equivalent`方法。程序员总是抱怨写这些看似多余的代码，但是多些一行代码的代价比起一个消除一个严重的隐藏bug来还是微不足道的。\nListing 0.1. Eliminate fragile base classes using interfaces\n\n\t 1| import java.util.*;\n\t 2| \n\t 3| interface Stack\n\t 4| {\n\t 5|　　 \tvoid push( Object o );\n\t 6|　　 \tObject pop();\n\t 7|　　 \tvoid push_many( Object[] source );\n\t 8| }\n\t 9| \n\t10| class Simple_stack `implements` Stack\n\t11| {   private int stack_pointer = -1;\n\t12|　　 \tprivate Object[] stack = new Object[1000];\n\t13| \n\t14|　　 public void push( Object o )\n\t15|　　 {   \tassert stack_pointer < stack.length;\n\t16| \n\t17|　　 \t\tstack[ ++stack_pointer ] = o;\n\t18|　　 }\n\t19| \n\t20|　　 public Object pop()\n\t21|　　 {   \tassert stack_pointer >= 0;\n\t22| \n\t23|　　 \t\treturn stack[ stack_pointer-- ];\n\t24|　　 }\n\t25| \n\t26|　　 public void push_many( Object[] source )\n\t27|　　 {   \tassert (stack_pointer + source.length) < stack.length;\n\t28| \n\t29|　　 \t\tSystem.arraycopy(source,0,stack,stack_pointer+1,source.length);\n\t30|　　 \t\tstack_pointer += source.length;\n\t31|　　 }\n\t32| }\n\t33| \n\t34| \n\t35| class Monitorable_Stack `implements` Stack\n\t36| {\n\t37|　　 private int high_water_mark = 0;\n\t38|　　 private int current_size;\n\t39|　　 Simple_stack stack = new Simple_stack();\n\t40| \n\t41|　　 public void push( Object o )\n\t42|　　 {   if( ++current_size > high_water_mark )\n\t43|　　　　 \t\thigh_water_mark = current_size;\n\t44|　　 \t\tstack.push(o);\n\t45|　　 }\n\t46|　　 \n\t47|　　 public Object pop()\n\t48|　　 {   \t--current_size;\n\t49|　　 \t\treturn stack.pop();\n\t50|　　 }\n\t51| \n\t52|　　 public void push_many( Object[] source )\n\t53|　　 {\n\t54|　　 \t\tif( current_size + source.length > high_water_mark )\n\t55|　　　　\t\thigh_water_mark = current_size + source.length;\n\t56| \n\t57|　　 \t\tstack.push_many( source );\n\t58|　　 }\n\t59| \n\t60|　　 public int maximum_size()\n\t61|　　 {   return high_water_mark;\n\t62|　　 }\n\t63| }\n\t64| \n## 框架\n　　脱离了具体的程序架构来谈脆弱的基础类问题就是耍流氓。像MFC这样的框架已经成为了类库构建的流行方式。尽管MFC本身正在令人欣喜的逐渐衰弱，但是在微软商店里MFC框架还是拥有统治地位因为那里的程序员相信微软即正义。\n　　基于框架的系统通常开始于库提供的半成品类，你不需要做任何事，只要通过派生类去提供缺失的方法。典型的例子是Java的`Component`类里的`paint`方法，这个方法只不过是一个占位符；派生类必须提供真实的实现版本。\n　　你能适当的避免这类事情，但是基于类派生订制实现的类框架是极其脆弱的。基础类太脆弱了。当我在MFC中开发程序，我就要有随时改写程序以应对微软发布新版本的觉悟。今天可用的代码到了明天就未必了，因为基础类方法变了。\n　　所有的java包都是即插即用工作良好。你不需要继承任何东西并实现方法。这种即插即用的工作机构要好于基于派生的框架。它更易维护和使用并且不会把你的代码置于因为Sun公司修改类库实现而崩溃的风险之下。\n\n## 总结脆弱的基础类\n　　通常来讲，最好是避免使用具体的基础类和`extends`继承关系而以接口和`implements`实现关系取代。我的经验法则是我最少80%的代码需要基于接口重构。比如，我永远不会使用HashMap的引用，而是使用Map接口。（我这里使用宽泛的“接口”定义。当你看到InputStream如何实现你就会知道实际上它也是个接口，尽管在Java中是需要被实现的抽象类。）\n　　你使用越多的抽象，你就能获得越大的灵活性。在如今的商业环境里，开发过程中需求不断变化，这种灵活性是必须的。进一步，绝大多数的敏捷开发方法论（比如Crystal和极限开发）无法实施除非代码都是基于抽象的。\n　　如果你仔细阅读四人帮的设计模式，你会发现他们提供的许多方法都是消除了实现继承取而代之的是接口继承，这是大多数模式的普遍特征。这个重要的事实就是我们开头所说的：设计模式是被发现的而不是被发明的。设计模式总结了那些优美的、易于维护的代码。他告诉我们优美的、易于维护的代码都不惜一切代价避免实现继承。","source":"_posts/why-extends-is-evil.md","raw":"---\ntitle: 为什么extends是魔鬼\ndate: 2017-01-06 16:02:08\ntags:\n  - Java\n  - 继承\n  - 翻译\ncategories: Java\n\n---\n# 为什么extends是魔鬼\n**_通过使用接口替换具体的base类来改进你的代码_**\n\n[原文地址](http://www.javaworld.com/javaworld/jw-08-2003/jw-0801-toolbox.html)\n\n# 前言\n　　`extends`关键字是魔鬼。可能还没有达到Charles Manson的程度，但是也已经达到了需要敬而远之的地步。四人帮的设计模式一书详尽的讨论了使用接口继承(`implements`)替代实现继承(`extends`)。\n　　\n　　好的设计者基于接口编写代码而不是依靠具体的基础类。这篇文章阐述了为什么设计者有这种古怪习惯，以及介绍一些基于接口的编程基础。\n\n\n## 接口与类\n\n　　一次我去参加一个Java用户小组会议，当时Java的发明者James Gosling是主讲人。在那个另人难忘的提问环节，有人问他：“如果给你个机会重新设计JAVA，你会做些什么改变？”。他回答道：“我会去除类”。在哄堂大笑之后他解释到从本质上问题不出在类本身而出在实现继承关系上。(`extends`关系)。接口继承（`implements`关系）是更好的。你应该尽可能的避免实现继承关系无论在何时。\n<!--more-->\n## 失去灵活性\n　　为什么要避免实现继承关系？首当其冲的问题是明确使用具体的类名会把你与特定的实现捆绑在一起，这给以后的变更带来了不必要的麻烦。\n\n　　设计和开发并行是现代敏捷开发理念的核心观点。在完全设计好程序之前就已经开始着手开发了。这种技术悍然无视传统理论中开发之前必须有完备设计的观念，但是很多的成功项目都证明比起传统途径来你可以使用敏捷理念来更快速更有性价比的开发高质量代码。然而，在并行开发的理念中灵活性是核心理念。你不得不使你的代码能够做到只需很小的改动就能把新需求融合到现有的代码中去。\n\n　　只实现明确需要的特性而不是实现可能需要的特性并且包容变化。没有这种灵活性，并行开发是不可能的。\n\n　　面向接口编程是灵活结构的核心。为了说清为什么，让我们来看看当不用的时候会发生什么。思考以下代码\n\n\tf()\n\t{   LinkedList list = new LinkedList();\n\t\t//...\n\t\tg( list );\n\t}\n\tg( LinkedList list )\n\t{\n\t\tlist.add( ... );\n\t\tg2( list )\n\t}\n\n　　现在设想一个新的快速查找的需求出现了，因此LinkedList不能解决问题。你需要使用HashSet取代。在现在的代码里，这个改动不局限于一处因为你必须同事改动f函数和g函数以及所有像g函数那样获取这个list的方法。\n\n　　重写代码如下:\n\n\tf()\n\t{   Collection list = new LinkedList();\n\t\t//...\n\t\tg( list );\n\t}\n\tg( Collection list )\n\t{\n\t\tlist.add( ... );\n\t\tg2( list )\n\t}\n　　重构使得只需要简单的把new LinkedList( )替换成new HashSet( ) 酒可以把Link list改成hash表。就是这么神奇，不要其他任何改动。\n\n　　另一个例子，比较下以下两段代码：\n\t\n\tf()\n\t{   Collection c = new HashSet();\n\t\t//...\n\t\tg( c );\n\t}\n\tg( Collection c )\n\t{\n\t\tfor( Iterator i = c.iterator(); i.hasNext() ;)\n\t\tdo_something_with( i.next() );\n\t}\n\tf2()\n\t{   Collection c = new HashSet();\n\t\t//...\n\t\tg2( c.iterator() );\n\t}\n\tg2( Iterator i )\n\t{   while( i.hasNext() ;)\n\t\tdo_something_with( i.next() );\n\t}\n　　g2函数现在不仅可以遍历Collection的衍生对象也可以遍历像Map这种键值列表。事实上，你能使用迭代器生成数据而不是遍历集合。你可以使用迭代器为程序从测试框架或者文件中收集信息。这里面有巨大的灵活性\n\n## 耦合\n　　实现继承的一个更关键的问题时耦合——一部分模块对另一部分不恰当的依赖。强耦合带来麻烦最经典的例子是全局变量。比如你改变了全局变量的类型，所有使用这个变量（也就是耦合于此变量）的所有函数都会收到影响，因此所有的代码都必须被检查、修改、重新测试。进一步，所有函数都因为使用了这个变量而被彼此耦合在一起。如果一个方法在不恰当的时间修改了变量的值那么它就可能错误的影响了其他函数的表现。这个问题在多线程的程序中特别的可怕。\n\n　　作为一个设计这，你应该致力于构建最小的耦合关系。你不能完全消除耦合因为一个类对象调用另一个对象的方法是松耦合的一种形式。一个没有耦合的程序是天方夜谭。虽然如此，你只要闭着眼睛去遵循OO的戒律（最重要的是一个类的实现应该对调用的类完全隐藏）就能把耦合降到最低。比如类实例变量（不是常量的成员字段）应该始终是私有的。句号！毫无例外！永远！（你能偶尔有效地使用`protected`方法，但是`protected`实例变量是被唾弃的）你永远不应该使用get/set方法因为相同的原因——它只是用一个非常复杂的方法使成员变成了共有的（虽然返回成熟对象的存取方法而不是基本类型值在某些情况下是合理的，比如当返回的对象在设计中是一个关键的抽象）\n\n　　我不是在这卖弄学问。我已经找到了一条途径去解决严格的OO方法、快速开发和易维护性之间的矛盾。每当我违反一条OO的核心原则类似实现隐藏，最终否导致我必须重写那些代码（最常见的原因是不能进行debug）。我没有时间重写代码，所以我遵循这些规则。我的顾虑都是很实际的而不是为了完美而完美。\n\n## 脆弱的基础类问题\n　　现在，让我们把耦合的概念应用到继承.在一个使用`extends`的实现继承系统里,衍生类与基础类有着非常紧密的耦合。这种密切的联系是不可取的。设计者给这种行为起了个绰号“脆弱的基础类问题”。基础类被认为是脆弱的因为你能用一种看似看全的方法修改技术类，但是这个新的行为当被衍生类继承后可能导致衍生类出现故障。你不能简单说一个基础类是否安全仅仅是通过单独测试基础类的方法。你也必须测试所有的衍生类。进一步，你必须检查所有使用基础类和衍生类对象的代码，因为这些代码可能被新的行为破坏。一个简单的关键基础类的变动可能导致整个程序无法工作。\n\n　　让我们一起检查脆弱的基础类和基础类耦合问题。下面的类继承了Java的ArrayList类并添加一个类似于栈的新行为：\n\n\tclass Stack extends ArrayList\n\t{   private int stack_pointer = 0;\n\t\tpublic void push( Object article )\n\t\t{   add( stack_pointer++, article );\n\t\t}\n\t\tpublic Object pop()\n\t\t{   return remove( --stack_pointer );\n\t\t}\n\t\tpublic void push_many( Object[] articles )\n\t\t{   for( int i = 0; i < articles.length; ++i )\n\t\t\tpush( articles[i] );\n\t\t}\n\t}\n　　如此之简单的类都会有问题。考虑当一个用户利用继承并使用`ArrayList`的`clear()`方法去清空栈：\n\n\tStack a_stack = new Stack();\n\ta_stack.push(\"1\");\n\ta_stack.push(\"2\");\n\ta_stack.clear();\n　　代码成功编译，但因为基础类不知道`stack_pointer`的存在，这个栈对象现在是没有定义的状态。下一个调用`push()`你压入新的元素在序列2处（`stack_pointer`当前值），因此栈事实上有3个元素，底部的两个变成了脏数据。（Java的栈类有相同的问题，不要使用他）。\n\n　　一个解决这个方法继承不当的问题是为栈重写所有的`ArrayList`方法使其能修改队列状态，重写那些方法去正确操作`stack_pointer`或者抛出异常。（`removeRange()`方法是一个很好的抛出异常的候选者）\n\n　　这个方法有两个劣势。首先，你重写了所有方法，基础类实际上变成了一个接口，不是一个类。既然你不使用任何继承方法那么实现继承还有任何意义吗？其次，一个更重要的原因，你不想栈支持所有的`ArrayList`方法。例如烦人的`removeRange`方法就毫无用处。对于继承来的无用的方法唯一可行的办法是抛出异常，因为它应该永远不会被调用。这种方式实际上把一个编译错误变成了运行时错误。非常不好。如果一个方法不是简单因为未被声明而被编译器检查出方法未找到错误。如果方法仅仅是抛出异常，那么你在程序运行钱都不会发现调用错误。\n\n　　一个更好的基础类解决方案是封装数据机构代替使用继承。下面是一个新的改进过的栈版本\n\n\tclass Stack\n\t{   private int stack_pointer = 0;\n\t\tprivate ArrayList the_data = new ArrayList();\n\t\tpublic void push( Object article )\n\t\t{   the_data.add( stack_pointer++, article );\n\t\t}\n\t\tpublic Object pop()\n\t\t{   return the_data.remove( --stack_pointer );\n\t\t}\n\t\tpublic void push_many( Object[] articles )\n\t\t{   for( int i = 0; i < o.length; ++i )\n\t\t\tpush( articles[i] );\n\t\t}\n\t}\n　　到目前为止看起来还不错，但是考虑考虑脆弱的基础类问题。让我们看下当你想创建一个栈的变体用来跟踪确定时间端内栈的最大值，一个可能的实现如下所示：\n\n\tclass Monitorable_stack extends Stack\n\t{\n\t\tprivate int high_water_mark = 0;\n\t\tprivate int current_size;\n\t\tpublic void push( Object article )\n\t\t{   if( ++current_size > high_water_mark )\n\t\t\thigh_water_mark = current_size;\n\t\t\tsuper.push(article);\n\t\t}\n\t\tpublic Object pop()\n\t\t{   --current_size;\n\t\t\treturn super.pop();\n\t\t}\n\t\tpublic int maximum_size_so_far()\n\t\t{   return high_water_mark;\n\t\t}\n\t}\n　　这个新对象运行正常，至少暂时是这样，不幸的是这段代码利用了一个事实那就是`push_many()`是通过调用`push()`来完成它的工作的。其实，这些细节似乎不是一个坏的选择。这简化了代码，你通过重载`push()`版本来实现，即使当`Monitorable_stact`通过获得一个`stack`引用来实现的，所以`high_water_mark`正确的更新了。\n　　\n　　在一个阳光明媚的日子，某人可能跑了一个性能测试并且注意到Stack类在被大量使用时运行效率不太理想。你决定重写Stack并且放弃使用ArrayList，因此你提高了Stack类的性能。下面是新类的部分核心代码：\n\n\tclass Stack\n\t{   private int stack_pointer = -1;\n\t\tprivate Object[] stack = new Object[1000];\n\t\tpublic void push( Object article )\n\t\t{   assert stack_pointer < stack.length;\n\t\t\tstack[ ++stack_pointer ] = article;\n\t\t}\n\t\tpublic Object pop()\n\t\t{   assert stack_pointer >= 0;\n\t\t\treturn stack[ stack_pointer-- ];\n\t\t}\n\t\tpublic void push_many( Object[] articles )\n\t\t{   assert (stack_pointer + articles.length) < stack.length;\n\t\t\tSystem.arraycopy(articles, 0, stack, stack_pointer+1,\n\t\t\t\t\t\t\t\tarticles.length);\n\t\t\tstack_pointer += articles.length;\n\t\t}\n\t}\n　　注意`push_many()`不再重复调用`push( )`而是使用了块转移。新的栈版本工作的很好；事实上，它比前个版本要更好。不幸的是，`Monitorable_stack`衍生类将不再工作，因为当`push_many`被调用是它不能正确的跟踪栈的使用情况。（衍生类的push版本不再被`push_many`调用，所以`push_many`也不再更新high_water_mark）。Stack就是脆弱的基础类。事实证明，通过谨慎的做法来解决这些问题几乎是不可能的。\n　　\n　　记住，如果你使用接口继承就不会有这些问题，因为没有继承的方法会对你产生不利的影响。如果Stack是接口，通过同时实现`Simple_stack`和`Monitorable_stack`来使用,代码会变得更健壮。\n　　\n　　我在清单0.1中提供一个基于接口的解决方案。这个解决方案和实现继承方案有相同的灵活性：你能在Stack抽象基础上构建你的代码为不用担心你究竟是在操作哪种具体类型的栈。既然两个实现类必须提供公共接口中的所有东西的实现版本，因此很难出现前面所讲的问题。虽然不使用基础类我仍然能获得类似的好处，因为我使用了封装而不是派生。另一方面，在封装类中我不得不使用没有价值的访问方法去访问默认的实现。(比如在第41行`Monitorable_Stack.push(…）`不得不在`Simp_stack`中调用`equivalent`方法。程序员总是抱怨写这些看似多余的代码，但是多些一行代码的代价比起一个消除一个严重的隐藏bug来还是微不足道的。\nListing 0.1. Eliminate fragile base classes using interfaces\n\n\t 1| import java.util.*;\n\t 2| \n\t 3| interface Stack\n\t 4| {\n\t 5|　　 \tvoid push( Object o );\n\t 6|　　 \tObject pop();\n\t 7|　　 \tvoid push_many( Object[] source );\n\t 8| }\n\t 9| \n\t10| class Simple_stack `implements` Stack\n\t11| {   private int stack_pointer = -1;\n\t12|　　 \tprivate Object[] stack = new Object[1000];\n\t13| \n\t14|　　 public void push( Object o )\n\t15|　　 {   \tassert stack_pointer < stack.length;\n\t16| \n\t17|　　 \t\tstack[ ++stack_pointer ] = o;\n\t18|　　 }\n\t19| \n\t20|　　 public Object pop()\n\t21|　　 {   \tassert stack_pointer >= 0;\n\t22| \n\t23|　　 \t\treturn stack[ stack_pointer-- ];\n\t24|　　 }\n\t25| \n\t26|　　 public void push_many( Object[] source )\n\t27|　　 {   \tassert (stack_pointer + source.length) < stack.length;\n\t28| \n\t29|　　 \t\tSystem.arraycopy(source,0,stack,stack_pointer+1,source.length);\n\t30|　　 \t\tstack_pointer += source.length;\n\t31|　　 }\n\t32| }\n\t33| \n\t34| \n\t35| class Monitorable_Stack `implements` Stack\n\t36| {\n\t37|　　 private int high_water_mark = 0;\n\t38|　　 private int current_size;\n\t39|　　 Simple_stack stack = new Simple_stack();\n\t40| \n\t41|　　 public void push( Object o )\n\t42|　　 {   if( ++current_size > high_water_mark )\n\t43|　　　　 \t\thigh_water_mark = current_size;\n\t44|　　 \t\tstack.push(o);\n\t45|　　 }\n\t46|　　 \n\t47|　　 public Object pop()\n\t48|　　 {   \t--current_size;\n\t49|　　 \t\treturn stack.pop();\n\t50|　　 }\n\t51| \n\t52|　　 public void push_many( Object[] source )\n\t53|　　 {\n\t54|　　 \t\tif( current_size + source.length > high_water_mark )\n\t55|　　　　\t\thigh_water_mark = current_size + source.length;\n\t56| \n\t57|　　 \t\tstack.push_many( source );\n\t58|　　 }\n\t59| \n\t60|　　 public int maximum_size()\n\t61|　　 {   return high_water_mark;\n\t62|　　 }\n\t63| }\n\t64| \n## 框架\n　　脱离了具体的程序架构来谈脆弱的基础类问题就是耍流氓。像MFC这样的框架已经成为了类库构建的流行方式。尽管MFC本身正在令人欣喜的逐渐衰弱，但是在微软商店里MFC框架还是拥有统治地位因为那里的程序员相信微软即正义。\n　　基于框架的系统通常开始于库提供的半成品类，你不需要做任何事，只要通过派生类去提供缺失的方法。典型的例子是Java的`Component`类里的`paint`方法，这个方法只不过是一个占位符；派生类必须提供真实的实现版本。\n　　你能适当的避免这类事情，但是基于类派生订制实现的类框架是极其脆弱的。基础类太脆弱了。当我在MFC中开发程序，我就要有随时改写程序以应对微软发布新版本的觉悟。今天可用的代码到了明天就未必了，因为基础类方法变了。\n　　所有的java包都是即插即用工作良好。你不需要继承任何东西并实现方法。这种即插即用的工作机构要好于基于派生的框架。它更易维护和使用并且不会把你的代码置于因为Sun公司修改类库实现而崩溃的风险之下。\n\n## 总结脆弱的基础类\n　　通常来讲，最好是避免使用具体的基础类和`extends`继承关系而以接口和`implements`实现关系取代。我的经验法则是我最少80%的代码需要基于接口重构。比如，我永远不会使用HashMap的引用，而是使用Map接口。（我这里使用宽泛的“接口”定义。当你看到InputStream如何实现你就会知道实际上它也是个接口，尽管在Java中是需要被实现的抽象类。）\n　　你使用越多的抽象，你就能获得越大的灵活性。在如今的商业环境里，开发过程中需求不断变化，这种灵活性是必须的。进一步，绝大多数的敏捷开发方法论（比如Crystal和极限开发）无法实施除非代码都是基于抽象的。\n　　如果你仔细阅读四人帮的设计模式，你会发现他们提供的许多方法都是消除了实现继承取而代之的是接口继承，这是大多数模式的普遍特征。这个重要的事实就是我们开头所说的：设计模式是被发现的而不是被发明的。设计模式总结了那些优美的、易于维护的代码。他告诉我们优美的、易于维护的代码都不惜一切代价避免实现继承。","slug":"why-extends-is-evil","published":1,"updated":"2017-07-06T09:08:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tf869900026b6nd2euot4d","content":"<h1 id=\"为什么extends是魔鬼\"><a href=\"#为什么extends是魔鬼\" class=\"headerlink\" title=\"为什么extends是魔鬼\"></a>为什么extends是魔鬼</h1><p><strong><em>通过使用接口替换具体的base类来改进你的代码</em></strong></p>\n<p><a href=\"http://www.javaworld.com/javaworld/jw-08-2003/jw-0801-toolbox.html\" target=\"_blank\" rel=\"external\">原文地址</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>　　<code>extends</code>关键字是魔鬼。可能还没有达到Charles Manson的程度，但是也已经达到了需要敬而远之的地步。四人帮的设计模式一书详尽的讨论了使用接口继承(<code>implements</code>)替代实现继承(<code>extends</code>)。<br>　　<br>　　好的设计者基于接口编写代码而不是依靠具体的基础类。这篇文章阐述了为什么设计者有这种古怪习惯，以及介绍一些基于接口的编程基础。</p>\n<h2 id=\"接口与类\"><a href=\"#接口与类\" class=\"headerlink\" title=\"接口与类\"></a>接口与类</h2><p>　　一次我去参加一个Java用户小组会议，当时Java的发明者James Gosling是主讲人。在那个另人难忘的提问环节，有人问他：“如果给你个机会重新设计JAVA，你会做些什么改变？”。他回答道：“我会去除类”。在哄堂大笑之后他解释到从本质上问题不出在类本身而出在实现继承关系上。(<code>extends</code>关系)。接口继承（<code>implements</code>关系）是更好的。你应该尽可能的避免实现继承关系无论在何时。<br><a id=\"more\"></a></p>\n<h2 id=\"失去灵活性\"><a href=\"#失去灵活性\" class=\"headerlink\" title=\"失去灵活性\"></a>失去灵活性</h2><p>　　为什么要避免实现继承关系？首当其冲的问题是明确使用具体的类名会把你与特定的实现捆绑在一起，这给以后的变更带来了不必要的麻烦。</p>\n<p>　　设计和开发并行是现代敏捷开发理念的核心观点。在完全设计好程序之前就已经开始着手开发了。这种技术悍然无视传统理论中开发之前必须有完备设计的观念，但是很多的成功项目都证明比起传统途径来你可以使用敏捷理念来更快速更有性价比的开发高质量代码。然而，在并行开发的理念中灵活性是核心理念。你不得不使你的代码能够做到只需很小的改动就能把新需求融合到现有的代码中去。</p>\n<p>　　只实现明确需要的特性而不是实现可能需要的特性并且包容变化。没有这种灵活性，并行开发是不可能的。</p>\n<p>　　面向接口编程是灵活结构的核心。为了说清为什么，让我们来看看当不用的时候会发生什么。思考以下代码</p>\n<pre><code>f()\n{   LinkedList list = new LinkedList();\n    //...\n    g( list );\n}\ng( LinkedList list )\n{\n    list.add( ... );\n    g2( list )\n}\n</code></pre><p>　　现在设想一个新的快速查找的需求出现了，因此LinkedList不能解决问题。你需要使用HashSet取代。在现在的代码里，这个改动不局限于一处因为你必须同事改动f函数和g函数以及所有像g函数那样获取这个list的方法。</p>\n<p>　　重写代码如下:</p>\n<pre><code>f()\n{   Collection list = new LinkedList();\n    //...\n    g( list );\n}\ng( Collection list )\n{\n    list.add( ... );\n    g2( list )\n}\n</code></pre><p>　　重构使得只需要简单的把new LinkedList( )替换成new HashSet( ) 酒可以把Link list改成hash表。就是这么神奇，不要其他任何改动。</p>\n<p>　　另一个例子，比较下以下两段代码：</p>\n<pre><code>f()\n{   Collection c = new HashSet();\n    //...\n    g( c );\n}\ng( Collection c )\n{\n    for( Iterator i = c.iterator(); i.hasNext() ;)\n    do_something_with( i.next() );\n}\nf2()\n{   Collection c = new HashSet();\n    //...\n    g2( c.iterator() );\n}\ng2( Iterator i )\n{   while( i.hasNext() ;)\n    do_something_with( i.next() );\n}\n</code></pre><p>　　g2函数现在不仅可以遍历Collection的衍生对象也可以遍历像Map这种键值列表。事实上，你能使用迭代器生成数据而不是遍历集合。你可以使用迭代器为程序从测试框架或者文件中收集信息。这里面有巨大的灵活性</p>\n<h2 id=\"耦合\"><a href=\"#耦合\" class=\"headerlink\" title=\"耦合\"></a>耦合</h2><p>　　实现继承的一个更关键的问题时耦合——一部分模块对另一部分不恰当的依赖。强耦合带来麻烦最经典的例子是全局变量。比如你改变了全局变量的类型，所有使用这个变量（也就是耦合于此变量）的所有函数都会收到影响，因此所有的代码都必须被检查、修改、重新测试。进一步，所有函数都因为使用了这个变量而被彼此耦合在一起。如果一个方法在不恰当的时间修改了变量的值那么它就可能错误的影响了其他函数的表现。这个问题在多线程的程序中特别的可怕。</p>\n<p>　　作为一个设计这，你应该致力于构建最小的耦合关系。你不能完全消除耦合因为一个类对象调用另一个对象的方法是松耦合的一种形式。一个没有耦合的程序是天方夜谭。虽然如此，你只要闭着眼睛去遵循OO的戒律（最重要的是一个类的实现应该对调用的类完全隐藏）就能把耦合降到最低。比如类实例变量（不是常量的成员字段）应该始终是私有的。句号！毫无例外！永远！（你能偶尔有效地使用<code>protected</code>方法，但是<code>protected</code>实例变量是被唾弃的）你永远不应该使用get/set方法因为相同的原因——它只是用一个非常复杂的方法使成员变成了共有的（虽然返回成熟对象的存取方法而不是基本类型值在某些情况下是合理的，比如当返回的对象在设计中是一个关键的抽象）</p>\n<p>　　我不是在这卖弄学问。我已经找到了一条途径去解决严格的OO方法、快速开发和易维护性之间的矛盾。每当我违反一条OO的核心原则类似实现隐藏，最终否导致我必须重写那些代码（最常见的原因是不能进行debug）。我没有时间重写代码，所以我遵循这些规则。我的顾虑都是很实际的而不是为了完美而完美。</p>\n<h2 id=\"脆弱的基础类问题\"><a href=\"#脆弱的基础类问题\" class=\"headerlink\" title=\"脆弱的基础类问题\"></a>脆弱的基础类问题</h2><p>　　现在，让我们把耦合的概念应用到继承.在一个使用<code>extends</code>的实现继承系统里,衍生类与基础类有着非常紧密的耦合。这种密切的联系是不可取的。设计者给这种行为起了个绰号“脆弱的基础类问题”。基础类被认为是脆弱的因为你能用一种看似看全的方法修改技术类，但是这个新的行为当被衍生类继承后可能导致衍生类出现故障。你不能简单说一个基础类是否安全仅仅是通过单独测试基础类的方法。你也必须测试所有的衍生类。进一步，你必须检查所有使用基础类和衍生类对象的代码，因为这些代码可能被新的行为破坏。一个简单的关键基础类的变动可能导致整个程序无法工作。</p>\n<p>　　让我们一起检查脆弱的基础类和基础类耦合问题。下面的类继承了Java的ArrayList类并添加一个类似于栈的新行为：</p>\n<pre><code>class Stack extends ArrayList\n{   private int stack_pointer = 0;\n    public void push( Object article )\n    {   add( stack_pointer++, article );\n    }\n    public Object pop()\n    {   return remove( --stack_pointer );\n    }\n    public void push_many( Object[] articles )\n    {   for( int i = 0; i &lt; articles.length; ++i )\n        push( articles[i] );\n    }\n}\n</code></pre><p>　　如此之简单的类都会有问题。考虑当一个用户利用继承并使用<code>ArrayList</code>的<code>clear()</code>方法去清空栈：</p>\n<pre><code>Stack a_stack = new Stack();\na_stack.push(&quot;1&quot;);\na_stack.push(&quot;2&quot;);\na_stack.clear();\n</code></pre><p>　　代码成功编译，但因为基础类不知道<code>stack_pointer</code>的存在，这个栈对象现在是没有定义的状态。下一个调用<code>push()</code>你压入新的元素在序列2处（<code>stack_pointer</code>当前值），因此栈事实上有3个元素，底部的两个变成了脏数据。（Java的栈类有相同的问题，不要使用他）。</p>\n<p>　　一个解决这个方法继承不当的问题是为栈重写所有的<code>ArrayList</code>方法使其能修改队列状态，重写那些方法去正确操作<code>stack_pointer</code>或者抛出异常。（<code>removeRange()</code>方法是一个很好的抛出异常的候选者）</p>\n<p>　　这个方法有两个劣势。首先，你重写了所有方法，基础类实际上变成了一个接口，不是一个类。既然你不使用任何继承方法那么实现继承还有任何意义吗？其次，一个更重要的原因，你不想栈支持所有的<code>ArrayList</code>方法。例如烦人的<code>removeRange</code>方法就毫无用处。对于继承来的无用的方法唯一可行的办法是抛出异常，因为它应该永远不会被调用。这种方式实际上把一个编译错误变成了运行时错误。非常不好。如果一个方法不是简单因为未被声明而被编译器检查出方法未找到错误。如果方法仅仅是抛出异常，那么你在程序运行钱都不会发现调用错误。</p>\n<p>　　一个更好的基础类解决方案是封装数据机构代替使用继承。下面是一个新的改进过的栈版本</p>\n<pre><code>class Stack\n{   private int stack_pointer = 0;\n    private ArrayList the_data = new ArrayList();\n    public void push( Object article )\n    {   the_data.add( stack_pointer++, article );\n    }\n    public Object pop()\n    {   return the_data.remove( --stack_pointer );\n    }\n    public void push_many( Object[] articles )\n    {   for( int i = 0; i &lt; o.length; ++i )\n        push( articles[i] );\n    }\n}\n</code></pre><p>　　到目前为止看起来还不错，但是考虑考虑脆弱的基础类问题。让我们看下当你想创建一个栈的变体用来跟踪确定时间端内栈的最大值，一个可能的实现如下所示：</p>\n<pre><code>class Monitorable_stack extends Stack\n{\n    private int high_water_mark = 0;\n    private int current_size;\n    public void push( Object article )\n    {   if( ++current_size &gt; high_water_mark )\n        high_water_mark = current_size;\n        super.push(article);\n    }\n    public Object pop()\n    {   --current_size;\n        return super.pop();\n    }\n    public int maximum_size_so_far()\n    {   return high_water_mark;\n    }\n}\n</code></pre><p>　　这个新对象运行正常，至少暂时是这样，不幸的是这段代码利用了一个事实那就是<code>push_many()</code>是通过调用<code>push()</code>来完成它的工作的。其实，这些细节似乎不是一个坏的选择。这简化了代码，你通过重载<code>push()</code>版本来实现，即使当<code>Monitorable_stact</code>通过获得一个<code>stack</code>引用来实现的，所以<code>high_water_mark</code>正确的更新了。<br>　　<br>　　在一个阳光明媚的日子，某人可能跑了一个性能测试并且注意到Stack类在被大量使用时运行效率不太理想。你决定重写Stack并且放弃使用ArrayList，因此你提高了Stack类的性能。下面是新类的部分核心代码：</p>\n<pre><code>class Stack\n{   private int stack_pointer = -1;\n    private Object[] stack = new Object[1000];\n    public void push( Object article )\n    {   assert stack_pointer &lt; stack.length;\n        stack[ ++stack_pointer ] = article;\n    }\n    public Object pop()\n    {   assert stack_pointer &gt;= 0;\n        return stack[ stack_pointer-- ];\n    }\n    public void push_many( Object[] articles )\n    {   assert (stack_pointer + articles.length) &lt; stack.length;\n        System.arraycopy(articles, 0, stack, stack_pointer+1,\n                            articles.length);\n        stack_pointer += articles.length;\n    }\n}\n</code></pre><p>　　注意<code>push_many()</code>不再重复调用<code>push( )</code>而是使用了块转移。新的栈版本工作的很好；事实上，它比前个版本要更好。不幸的是，<code>Monitorable_stack</code>衍生类将不再工作，因为当<code>push_many</code>被调用是它不能正确的跟踪栈的使用情况。（衍生类的push版本不再被<code>push_many</code>调用，所以<code>push_many</code>也不再更新high_water_mark）。Stack就是脆弱的基础类。事实证明，通过谨慎的做法来解决这些问题几乎是不可能的。<br>　　<br>　　记住，如果你使用接口继承就不会有这些问题，因为没有继承的方法会对你产生不利的影响。如果Stack是接口，通过同时实现<code>Simple_stack</code>和<code>Monitorable_stack</code>来使用,代码会变得更健壮。<br>　　<br>　　我在清单0.1中提供一个基于接口的解决方案。这个解决方案和实现继承方案有相同的灵活性：你能在Stack抽象基础上构建你的代码为不用担心你究竟是在操作哪种具体类型的栈。既然两个实现类必须提供公共接口中的所有东西的实现版本，因此很难出现前面所讲的问题。虽然不使用基础类我仍然能获得类似的好处，因为我使用了封装而不是派生。另一方面，在封装类中我不得不使用没有价值的访问方法去访问默认的实现。(比如在第41行<code>Monitorable_Stack.push(…）</code>不得不在<code>Simp_stack</code>中调用<code>equivalent</code>方法。程序员总是抱怨写这些看似多余的代码，但是多些一行代码的代价比起一个消除一个严重的隐藏bug来还是微不足道的。<br>Listing 0.1. Eliminate fragile base classes using interfaces</p>\n<pre><code> 1| import java.util.*;\n 2| \n 3| interface Stack\n 4| {\n 5|　　     void push( Object o );\n 6|　　     Object pop();\n 7|　　     void push_many( Object[] source );\n 8| }\n 9| \n10| class Simple_stack `implements` Stack\n11| {   private int stack_pointer = -1;\n12|　　     private Object[] stack = new Object[1000];\n13| \n14|　　 public void push( Object o )\n15|　　 {       assert stack_pointer &lt; stack.length;\n16| \n17|　　         stack[ ++stack_pointer ] = o;\n18|　　 }\n19| \n20|　　 public Object pop()\n21|　　 {       assert stack_pointer &gt;= 0;\n22| \n23|　　         return stack[ stack_pointer-- ];\n24|　　 }\n25| \n26|　　 public void push_many( Object[] source )\n27|　　 {       assert (stack_pointer + source.length) &lt; stack.length;\n28| \n29|　　         System.arraycopy(source,0,stack,stack_pointer+1,source.length);\n30|　　         stack_pointer += source.length;\n31|　　 }\n32| }\n33| \n34| \n35| class Monitorable_Stack `implements` Stack\n36| {\n37|　　 private int high_water_mark = 0;\n38|　　 private int current_size;\n39|　　 Simple_stack stack = new Simple_stack();\n40| \n41|　　 public void push( Object o )\n42|　　 {   if( ++current_size &gt; high_water_mark )\n43|　　　　         high_water_mark = current_size;\n44|　　         stack.push(o);\n45|　　 }\n46|　　 \n47|　　 public Object pop()\n48|　　 {       --current_size;\n49|　　         return stack.pop();\n50|　　 }\n51| \n52|　　 public void push_many( Object[] source )\n53|　　 {\n54|　　         if( current_size + source.length &gt; high_water_mark )\n55|　　　　        high_water_mark = current_size + source.length;\n56| \n57|　　         stack.push_many( source );\n58|　　 }\n59| \n60|　　 public int maximum_size()\n61|　　 {   return high_water_mark;\n62|　　 }\n63| }\n64| \n</code></pre><h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><p>　　脱离了具体的程序架构来谈脆弱的基础类问题就是耍流氓。像MFC这样的框架已经成为了类库构建的流行方式。尽管MFC本身正在令人欣喜的逐渐衰弱，但是在微软商店里MFC框架还是拥有统治地位因为那里的程序员相信微软即正义。<br>　　基于框架的系统通常开始于库提供的半成品类，你不需要做任何事，只要通过派生类去提供缺失的方法。典型的例子是Java的<code>Component</code>类里的<code>paint</code>方法，这个方法只不过是一个占位符；派生类必须提供真实的实现版本。<br>　　你能适当的避免这类事情，但是基于类派生订制实现的类框架是极其脆弱的。基础类太脆弱了。当我在MFC中开发程序，我就要有随时改写程序以应对微软发布新版本的觉悟。今天可用的代码到了明天就未必了，因为基础类方法变了。<br>　　所有的java包都是即插即用工作良好。你不需要继承任何东西并实现方法。这种即插即用的工作机构要好于基于派生的框架。它更易维护和使用并且不会把你的代码置于因为Sun公司修改类库实现而崩溃的风险之下。</p>\n<h2 id=\"总结脆弱的基础类\"><a href=\"#总结脆弱的基础类\" class=\"headerlink\" title=\"总结脆弱的基础类\"></a>总结脆弱的基础类</h2><p>　　通常来讲，最好是避免使用具体的基础类和<code>extends</code>继承关系而以接口和<code>implements</code>实现关系取代。我的经验法则是我最少80%的代码需要基于接口重构。比如，我永远不会使用HashMap的引用，而是使用Map接口。（我这里使用宽泛的“接口”定义。当你看到InputStream如何实现你就会知道实际上它也是个接口，尽管在Java中是需要被实现的抽象类。）<br>　　你使用越多的抽象，你就能获得越大的灵活性。在如今的商业环境里，开发过程中需求不断变化，这种灵活性是必须的。进一步，绝大多数的敏捷开发方法论（比如Crystal和极限开发）无法实施除非代码都是基于抽象的。<br>　　如果你仔细阅读四人帮的设计模式，你会发现他们提供的许多方法都是消除了实现继承取而代之的是接口继承，这是大多数模式的普遍特征。这个重要的事实就是我们开头所说的：设计模式是被发现的而不是被发明的。设计模式总结了那些优美的、易于维护的代码。他告诉我们优美的、易于维护的代码都不惜一切代价避免实现继承。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"为什么extends是魔鬼\"><a href=\"#为什么extends是魔鬼\" class=\"headerlink\" title=\"为什么extends是魔鬼\"></a>为什么extends是魔鬼</h1><p><strong><em>通过使用接口替换具体的base类来改进你的代码</em></strong></p>\n<p><a href=\"http://www.javaworld.com/javaworld/jw-08-2003/jw-0801-toolbox.html\" target=\"_blank\" rel=\"external\">原文地址</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>　　<code>extends</code>关键字是魔鬼。可能还没有达到Charles Manson的程度，但是也已经达到了需要敬而远之的地步。四人帮的设计模式一书详尽的讨论了使用接口继承(<code>implements</code>)替代实现继承(<code>extends</code>)。<br>　　<br>　　好的设计者基于接口编写代码而不是依靠具体的基础类。这篇文章阐述了为什么设计者有这种古怪习惯，以及介绍一些基于接口的编程基础。</p>\n<h2 id=\"接口与类\"><a href=\"#接口与类\" class=\"headerlink\" title=\"接口与类\"></a>接口与类</h2><p>　　一次我去参加一个Java用户小组会议，当时Java的发明者James Gosling是主讲人。在那个另人难忘的提问环节，有人问他：“如果给你个机会重新设计JAVA，你会做些什么改变？”。他回答道：“我会去除类”。在哄堂大笑之后他解释到从本质上问题不出在类本身而出在实现继承关系上。(<code>extends</code>关系)。接口继承（<code>implements</code>关系）是更好的。你应该尽可能的避免实现继承关系无论在何时。<br></p>","more":"<p></p>\n<h2 id=\"失去灵活性\"><a href=\"#失去灵活性\" class=\"headerlink\" title=\"失去灵活性\"></a>失去灵活性</h2><p>　　为什么要避免实现继承关系？首当其冲的问题是明确使用具体的类名会把你与特定的实现捆绑在一起，这给以后的变更带来了不必要的麻烦。</p>\n<p>　　设计和开发并行是现代敏捷开发理念的核心观点。在完全设计好程序之前就已经开始着手开发了。这种技术悍然无视传统理论中开发之前必须有完备设计的观念，但是很多的成功项目都证明比起传统途径来你可以使用敏捷理念来更快速更有性价比的开发高质量代码。然而，在并行开发的理念中灵活性是核心理念。你不得不使你的代码能够做到只需很小的改动就能把新需求融合到现有的代码中去。</p>\n<p>　　只实现明确需要的特性而不是实现可能需要的特性并且包容变化。没有这种灵活性，并行开发是不可能的。</p>\n<p>　　面向接口编程是灵活结构的核心。为了说清为什么，让我们来看看当不用的时候会发生什么。思考以下代码</p>\n<pre><code>f()\n{   LinkedList list = new LinkedList();\n    //...\n    g( list );\n}\ng( LinkedList list )\n{\n    list.add( ... );\n    g2( list )\n}\n</code></pre><p>　　现在设想一个新的快速查找的需求出现了，因此LinkedList不能解决问题。你需要使用HashSet取代。在现在的代码里，这个改动不局限于一处因为你必须同事改动f函数和g函数以及所有像g函数那样获取这个list的方法。</p>\n<p>　　重写代码如下:</p>\n<pre><code>f()\n{   Collection list = new LinkedList();\n    //...\n    g( list );\n}\ng( Collection list )\n{\n    list.add( ... );\n    g2( list )\n}\n</code></pre><p>　　重构使得只需要简单的把new LinkedList( )替换成new HashSet( ) 酒可以把Link list改成hash表。就是这么神奇，不要其他任何改动。</p>\n<p>　　另一个例子，比较下以下两段代码：</p>\n<pre><code>f()\n{   Collection c = new HashSet();\n    //...\n    g( c );\n}\ng( Collection c )\n{\n    for( Iterator i = c.iterator(); i.hasNext() ;)\n    do_something_with( i.next() );\n}\nf2()\n{   Collection c = new HashSet();\n    //...\n    g2( c.iterator() );\n}\ng2( Iterator i )\n{   while( i.hasNext() ;)\n    do_something_with( i.next() );\n}\n</code></pre><p>　　g2函数现在不仅可以遍历Collection的衍生对象也可以遍历像Map这种键值列表。事实上，你能使用迭代器生成数据而不是遍历集合。你可以使用迭代器为程序从测试框架或者文件中收集信息。这里面有巨大的灵活性</p>\n<h2 id=\"耦合\"><a href=\"#耦合\" class=\"headerlink\" title=\"耦合\"></a>耦合</h2><p>　　实现继承的一个更关键的问题时耦合——一部分模块对另一部分不恰当的依赖。强耦合带来麻烦最经典的例子是全局变量。比如你改变了全局变量的类型，所有使用这个变量（也就是耦合于此变量）的所有函数都会收到影响，因此所有的代码都必须被检查、修改、重新测试。进一步，所有函数都因为使用了这个变量而被彼此耦合在一起。如果一个方法在不恰当的时间修改了变量的值那么它就可能错误的影响了其他函数的表现。这个问题在多线程的程序中特别的可怕。</p>\n<p>　　作为一个设计这，你应该致力于构建最小的耦合关系。你不能完全消除耦合因为一个类对象调用另一个对象的方法是松耦合的一种形式。一个没有耦合的程序是天方夜谭。虽然如此，你只要闭着眼睛去遵循OO的戒律（最重要的是一个类的实现应该对调用的类完全隐藏）就能把耦合降到最低。比如类实例变量（不是常量的成员字段）应该始终是私有的。句号！毫无例外！永远！（你能偶尔有效地使用<code>protected</code>方法，但是<code>protected</code>实例变量是被唾弃的）你永远不应该使用get/set方法因为相同的原因——它只是用一个非常复杂的方法使成员变成了共有的（虽然返回成熟对象的存取方法而不是基本类型值在某些情况下是合理的，比如当返回的对象在设计中是一个关键的抽象）</p>\n<p>　　我不是在这卖弄学问。我已经找到了一条途径去解决严格的OO方法、快速开发和易维护性之间的矛盾。每当我违反一条OO的核心原则类似实现隐藏，最终否导致我必须重写那些代码（最常见的原因是不能进行debug）。我没有时间重写代码，所以我遵循这些规则。我的顾虑都是很实际的而不是为了完美而完美。</p>\n<h2 id=\"脆弱的基础类问题\"><a href=\"#脆弱的基础类问题\" class=\"headerlink\" title=\"脆弱的基础类问题\"></a>脆弱的基础类问题</h2><p>　　现在，让我们把耦合的概念应用到继承.在一个使用<code>extends</code>的实现继承系统里,衍生类与基础类有着非常紧密的耦合。这种密切的联系是不可取的。设计者给这种行为起了个绰号“脆弱的基础类问题”。基础类被认为是脆弱的因为你能用一种看似看全的方法修改技术类，但是这个新的行为当被衍生类继承后可能导致衍生类出现故障。你不能简单说一个基础类是否安全仅仅是通过单独测试基础类的方法。你也必须测试所有的衍生类。进一步，你必须检查所有使用基础类和衍生类对象的代码，因为这些代码可能被新的行为破坏。一个简单的关键基础类的变动可能导致整个程序无法工作。</p>\n<p>　　让我们一起检查脆弱的基础类和基础类耦合问题。下面的类继承了Java的ArrayList类并添加一个类似于栈的新行为：</p>\n<pre><code>class Stack extends ArrayList\n{   private int stack_pointer = 0;\n    public void push( Object article )\n    {   add( stack_pointer++, article );\n    }\n    public Object pop()\n    {   return remove( --stack_pointer );\n    }\n    public void push_many( Object[] articles )\n    {   for( int i = 0; i &lt; articles.length; ++i )\n        push( articles[i] );\n    }\n}\n</code></pre><p>　　如此之简单的类都会有问题。考虑当一个用户利用继承并使用<code>ArrayList</code>的<code>clear()</code>方法去清空栈：</p>\n<pre><code>Stack a_stack = new Stack();\na_stack.push(&quot;1&quot;);\na_stack.push(&quot;2&quot;);\na_stack.clear();\n</code></pre><p>　　代码成功编译，但因为基础类不知道<code>stack_pointer</code>的存在，这个栈对象现在是没有定义的状态。下一个调用<code>push()</code>你压入新的元素在序列2处（<code>stack_pointer</code>当前值），因此栈事实上有3个元素，底部的两个变成了脏数据。（Java的栈类有相同的问题，不要使用他）。</p>\n<p>　　一个解决这个方法继承不当的问题是为栈重写所有的<code>ArrayList</code>方法使其能修改队列状态，重写那些方法去正确操作<code>stack_pointer</code>或者抛出异常。（<code>removeRange()</code>方法是一个很好的抛出异常的候选者）</p>\n<p>　　这个方法有两个劣势。首先，你重写了所有方法，基础类实际上变成了一个接口，不是一个类。既然你不使用任何继承方法那么实现继承还有任何意义吗？其次，一个更重要的原因，你不想栈支持所有的<code>ArrayList</code>方法。例如烦人的<code>removeRange</code>方法就毫无用处。对于继承来的无用的方法唯一可行的办法是抛出异常，因为它应该永远不会被调用。这种方式实际上把一个编译错误变成了运行时错误。非常不好。如果一个方法不是简单因为未被声明而被编译器检查出方法未找到错误。如果方法仅仅是抛出异常，那么你在程序运行钱都不会发现调用错误。</p>\n<p>　　一个更好的基础类解决方案是封装数据机构代替使用继承。下面是一个新的改进过的栈版本</p>\n<pre><code>class Stack\n{   private int stack_pointer = 0;\n    private ArrayList the_data = new ArrayList();\n    public void push( Object article )\n    {   the_data.add( stack_pointer++, article );\n    }\n    public Object pop()\n    {   return the_data.remove( --stack_pointer );\n    }\n    public void push_many( Object[] articles )\n    {   for( int i = 0; i &lt; o.length; ++i )\n        push( articles[i] );\n    }\n}\n</code></pre><p>　　到目前为止看起来还不错，但是考虑考虑脆弱的基础类问题。让我们看下当你想创建一个栈的变体用来跟踪确定时间端内栈的最大值，一个可能的实现如下所示：</p>\n<pre><code>class Monitorable_stack extends Stack\n{\n    private int high_water_mark = 0;\n    private int current_size;\n    public void push( Object article )\n    {   if( ++current_size &gt; high_water_mark )\n        high_water_mark = current_size;\n        super.push(article);\n    }\n    public Object pop()\n    {   --current_size;\n        return super.pop();\n    }\n    public int maximum_size_so_far()\n    {   return high_water_mark;\n    }\n}\n</code></pre><p>　　这个新对象运行正常，至少暂时是这样，不幸的是这段代码利用了一个事实那就是<code>push_many()</code>是通过调用<code>push()</code>来完成它的工作的。其实，这些细节似乎不是一个坏的选择。这简化了代码，你通过重载<code>push()</code>版本来实现，即使当<code>Monitorable_stact</code>通过获得一个<code>stack</code>引用来实现的，所以<code>high_water_mark</code>正确的更新了。<br>　　<br>　　在一个阳光明媚的日子，某人可能跑了一个性能测试并且注意到Stack类在被大量使用时运行效率不太理想。你决定重写Stack并且放弃使用ArrayList，因此你提高了Stack类的性能。下面是新类的部分核心代码：</p>\n<pre><code>class Stack\n{   private int stack_pointer = -1;\n    private Object[] stack = new Object[1000];\n    public void push( Object article )\n    {   assert stack_pointer &lt; stack.length;\n        stack[ ++stack_pointer ] = article;\n    }\n    public Object pop()\n    {   assert stack_pointer &gt;= 0;\n        return stack[ stack_pointer-- ];\n    }\n    public void push_many( Object[] articles )\n    {   assert (stack_pointer + articles.length) &lt; stack.length;\n        System.arraycopy(articles, 0, stack, stack_pointer+1,\n                            articles.length);\n        stack_pointer += articles.length;\n    }\n}\n</code></pre><p>　　注意<code>push_many()</code>不再重复调用<code>push( )</code>而是使用了块转移。新的栈版本工作的很好；事实上，它比前个版本要更好。不幸的是，<code>Monitorable_stack</code>衍生类将不再工作，因为当<code>push_many</code>被调用是它不能正确的跟踪栈的使用情况。（衍生类的push版本不再被<code>push_many</code>调用，所以<code>push_many</code>也不再更新high_water_mark）。Stack就是脆弱的基础类。事实证明，通过谨慎的做法来解决这些问题几乎是不可能的。<br>　　<br>　　记住，如果你使用接口继承就不会有这些问题，因为没有继承的方法会对你产生不利的影响。如果Stack是接口，通过同时实现<code>Simple_stack</code>和<code>Monitorable_stack</code>来使用,代码会变得更健壮。<br>　　<br>　　我在清单0.1中提供一个基于接口的解决方案。这个解决方案和实现继承方案有相同的灵活性：你能在Stack抽象基础上构建你的代码为不用担心你究竟是在操作哪种具体类型的栈。既然两个实现类必须提供公共接口中的所有东西的实现版本，因此很难出现前面所讲的问题。虽然不使用基础类我仍然能获得类似的好处，因为我使用了封装而不是派生。另一方面，在封装类中我不得不使用没有价值的访问方法去访问默认的实现。(比如在第41行<code>Monitorable_Stack.push(…）</code>不得不在<code>Simp_stack</code>中调用<code>equivalent</code>方法。程序员总是抱怨写这些看似多余的代码，但是多些一行代码的代价比起一个消除一个严重的隐藏bug来还是微不足道的。<br>Listing 0.1. Eliminate fragile base classes using interfaces</p>\n<pre><code> 1| import java.util.*;\n 2| \n 3| interface Stack\n 4| {\n 5|　　     void push( Object o );\n 6|　　     Object pop();\n 7|　　     void push_many( Object[] source );\n 8| }\n 9| \n10| class Simple_stack `implements` Stack\n11| {   private int stack_pointer = -1;\n12|　　     private Object[] stack = new Object[1000];\n13| \n14|　　 public void push( Object o )\n15|　　 {       assert stack_pointer &lt; stack.length;\n16| \n17|　　         stack[ ++stack_pointer ] = o;\n18|　　 }\n19| \n20|　　 public Object pop()\n21|　　 {       assert stack_pointer &gt;= 0;\n22| \n23|　　         return stack[ stack_pointer-- ];\n24|　　 }\n25| \n26|　　 public void push_many( Object[] source )\n27|　　 {       assert (stack_pointer + source.length) &lt; stack.length;\n28| \n29|　　         System.arraycopy(source,0,stack,stack_pointer+1,source.length);\n30|　　         stack_pointer += source.length;\n31|　　 }\n32| }\n33| \n34| \n35| class Monitorable_Stack `implements` Stack\n36| {\n37|　　 private int high_water_mark = 0;\n38|　　 private int current_size;\n39|　　 Simple_stack stack = new Simple_stack();\n40| \n41|　　 public void push( Object o )\n42|　　 {   if( ++current_size &gt; high_water_mark )\n43|　　　　         high_water_mark = current_size;\n44|　　         stack.push(o);\n45|　　 }\n46|　　 \n47|　　 public Object pop()\n48|　　 {       --current_size;\n49|　　         return stack.pop();\n50|　　 }\n51| \n52|　　 public void push_many( Object[] source )\n53|　　 {\n54|　　         if( current_size + source.length &gt; high_water_mark )\n55|　　　　        high_water_mark = current_size + source.length;\n56| \n57|　　         stack.push_many( source );\n58|　　 }\n59| \n60|　　 public int maximum_size()\n61|　　 {   return high_water_mark;\n62|　　 }\n63| }\n64| \n</code></pre><h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><p>　　脱离了具体的程序架构来谈脆弱的基础类问题就是耍流氓。像MFC这样的框架已经成为了类库构建的流行方式。尽管MFC本身正在令人欣喜的逐渐衰弱，但是在微软商店里MFC框架还是拥有统治地位因为那里的程序员相信微软即正义。<br>　　基于框架的系统通常开始于库提供的半成品类，你不需要做任何事，只要通过派生类去提供缺失的方法。典型的例子是Java的<code>Component</code>类里的<code>paint</code>方法，这个方法只不过是一个占位符；派生类必须提供真实的实现版本。<br>　　你能适当的避免这类事情，但是基于类派生订制实现的类框架是极其脆弱的。基础类太脆弱了。当我在MFC中开发程序，我就要有随时改写程序以应对微软发布新版本的觉悟。今天可用的代码到了明天就未必了，因为基础类方法变了。<br>　　所有的java包都是即插即用工作良好。你不需要继承任何东西并实现方法。这种即插即用的工作机构要好于基于派生的框架。它更易维护和使用并且不会把你的代码置于因为Sun公司修改类库实现而崩溃的风险之下。</p>\n<h2 id=\"总结脆弱的基础类\"><a href=\"#总结脆弱的基础类\" class=\"headerlink\" title=\"总结脆弱的基础类\"></a>总结脆弱的基础类</h2><p>　　通常来讲，最好是避免使用具体的基础类和<code>extends</code>继承关系而以接口和<code>implements</code>实现关系取代。我的经验法则是我最少80%的代码需要基于接口重构。比如，我永远不会使用HashMap的引用，而是使用Map接口。（我这里使用宽泛的“接口”定义。当你看到InputStream如何实现你就会知道实际上它也是个接口，尽管在Java中是需要被实现的抽象类。）<br>　　你使用越多的抽象，你就能获得越大的灵活性。在如今的商业环境里，开发过程中需求不断变化，这种灵活性是必须的。进一步，绝大多数的敏捷开发方法论（比如Crystal和极限开发）无法实施除非代码都是基于抽象的。<br>　　如果你仔细阅读四人帮的设计模式，你会发现他们提供的许多方法都是消除了实现继承取而代之的是接口继承，这是大多数模式的普遍特征。这个重要的事实就是我们开头所说的：设计模式是被发现的而不是被发明的。设计模式总结了那些优美的、易于维护的代码。他告诉我们优美的、易于维护的代码都不惜一切代价避免实现继承。</p>"},{"title":"为什么getter和setter方法是魔鬼","date":"2017-01-10T07:19:24.000Z","_content":"# 为什么getter和setter方法是魔鬼\n**_通过避免使用存储器来使你的代码变得更易维护_**\n\n**[原文地址](http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html)**\n\n## 前言\n\n　　我没有打算开始一个“魔鬼的步伐”系列。但一些读者请我解释为什么我在上个月的专栏文章\"[Why extends Is Evil](http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html)”中提到你应该避免使用get/set方法。\n\n　　尽管getter/setter方法在Java中是很常见的，但是他们不是特别符合面向对象的思想。事实上，他们会使你的代码变得难易维护。此外，大量getter和setter方法的出现是一个危险信号，它意味着你的程序不能被很好的符合OO思想。\n\n　　这篇文章解释了为什么你不应该使用getters和setters方法（在你能用他们的时候），并且提出一个可以帮助你跳出getter/setter误区的设计思想。\n\n## 设计的本质\n\n　　在我开始一个具有有争议标题的技术专栏前，我想澄清一些事情。\n\n　　我被一些读者在\"[Why extends Is Evil](http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html)”一文下的评论给震惊了。一些人相信我宣称面向对象不是朴素的因为extents有问题，好像这两个论点是等价的。那绝对不是我想说的，所以我要澄清一些元问题（meta-issues）。\n<!--more-->\n　　这个专栏和过去几个月的文章都在讨论设计。设计从本质上来说以一种权衡。每一个选择都有其两面性，你需要在既定标准中做出决定。好和坏不是绝对的，一个好的决定一旦换了个环境就未必如此了。\n   \n　　如果你不能理解问题的两面性，你就不能做出一个明智的选择。事实上，如果你不理解每个行动会带来的所有后果，你就完全不能进行设计。你在黑暗中蹒跚前行。在“四人帮”的《设计模式》一书中每一章节都包含“Consequences”一小结用来说明哪些情况不适用当前模式，这绝不仅仅是一种偶然。\n\n　　阐述某些语言的特性或普遍的程序设计风格（比如存取方法）有问题不等于说你决不能在任何情况下使用他们。同样的，一个特性或风格被普遍使用不意味着你也可以使用它。那些不明就里的写了许多程序并且受雇于Sun或者微软的不明就里的程序员不能魔法般的提高程序开发和设计的能力。JAVA开发包中包含了很多伟大的代码。但是同样有一部分代码我确定是他们的作者羞于承认的。\n   \n　　出于同样的原因，营销或者政治动机经常推动着设计风格。有时候程序要做了错误的决定但是企业为了宣传他们的技术多牛B，所以他们前调你现在用的方法是不太理想的。当你仅仅是因为“这事你们应该这么干”而草率的接受了某些程序实践，那么你的行为是不负责任的。许多失败的EJB工程证明了这个原则。基于EJB的技术当你正确使用时是伟大的技术，但是当你滥用它的时候也能彻底的击倒一个企业。\n\n　　我的观点是你不能盲目的写程序。你必须理解一个特性或习惯所能造成的破坏。在这情况下，你会处于一个更有利的位置去决定是否需要使用这些特性或风格。你的选择会更合理更实用。这些文章的目的是帮助你用更开阔的视野去思考你的程序。\n\n## 数据抽象\n\n　　面向对象系统一个基本的原则是不要暴露任何实现细节。这样你可以修改你的实现而不改动用户代码。所以在面向对象系统中你应该避免getter和setter方法因为他们通常会保留实现细节。\n　　\n　　让我们来看为什么，假设在你的程序中有1000次的getX()方法的调用，每一个调用都假设了一个特定类型值的返回。你必须在本地变量中储层这个返回值，并且变量的类型必须和返回类型是相匹配的。如果你需要改变对象的实现从而导致X类型的改变，那么你就摊上大麻烦了。\n　　\n　　如果X曾是int型，但现在必须是long型，你会得到1000个编译错误。如果你只是简单的将返回值强制转换成int型，代码讲被编译通过，但未必能正常工作（返回值可能被截断）。为了这一个改动你必须逐一修改1000个调用。我肯定我不愿意去做这么多工作。\n　　\n　　面向对象系统的一个基本原则是数据抽象，你应该完全隐藏一个对象是如何处理从其他模块中获得的消息。这就是为什么你应该将所有实例对象(非常量)申明为private。\n   \n　　 如果你将一个成员申明为public,那么无论类发生了什么变化这个变量都不能被改变，因为你会破坏外部代码对这个成员的使用。你不会愿意搜索1000处调用仅仅是因为你改动了那个类。\n   \n　　隐藏实现原则提供了一个快速的检验OO系统质量的测试方法：你能否把类改得面目全非，却不影响任何用户的使用？模块化的匪类是面向对象的前提，它使得程序更易维护。没有实现的隐藏其他OO特性也就无从谈起。\n　　\n　　Getter和Setter方法（也被称为存储器）和公有成员变量都是危险的。他们暴露了实现细节。如果你要改变被访问字段的类型该怎么办？你也必须改变存储器的返回类型。你在无数地方使用了这个返回值，因此你必须全部更改这些代码。我希望限制修改单个类的所带来的影响，而不是波及到整个程序。\n\n　　既然存储器违反了封装原则，你就有理由主张一个过度滥用存储器的系统不符合面向对象思想。如果你不只是为了写代码而是认真检查设计流程，你能完全摒弃存储器，这个流程至关重要。我会在后文更详尽的阐述这个问题。\n\n　　减少getter/setter方法不意味着某些数据讲不能在系统中流动。尽管如此，数据流动还是越少越好。据我的经验系统可维护性是与数据在两个对象间交互的数量成反比的。经管你可能不知道，但是你可以消除绝大多数的数据移动。\n　　\n　　通过细致的设计并且着眼于你应该干什么而不是你怎么干，你可以消除绝大的多数的getter/setter方法。不要去请求完成工作需要的信息，而是让持有相关信息的对象去完成工作。大多数存储器提供了访问代码的手段因为设计者没有认真思考动态模型：为了完成工作所需要互相发送的动态对象和消息。他们的设计工作错误的由设计类的层级（类图）开始，然后试图把那些类强塞进动态模型。这种方式从来不能奏效。要设计一个静态模型，你需要发现类与类直接按的关联，这些关联完全与信息流相符合。一个联系存在与两个类之间，当且仅当有一个类的对象向其他类的对象发送了消息。静态模型的主要目的就是为你的动态模型捕捉这些关联。\n\n　　没有一个清晰的动态模型的定义，你只能猜想你会怎么使用一个类的对象。因此，存储方法会被大量绑定到模型上，你必须提供经可能多的存储方法因为你根本不能预测是否会用到他们。这类设计完全靠猜的策略是效率低下的。你把时间浪费在了写无用的方法上（或者给类加了不必要的能力）。\n\n　　存储器也是习惯思维的产物。当面向过程的程序员门接触到了Java，他们试图开始构建相似的代码。面向过程语言没有类，但他们有C结构体（struct,你可以把他看做没有方法的类）。然后理所当然地开始模仿设计结构体的方式去设计一个类，这个类除了公有成员没有其他的东西。这些面向过程的程序员们在其他一些地方知道了成员应该是私有的，然后他们把成员改成了私有并且提供了共有的存储方法。其实他们只是让共有调用变得复杂，而并没有让系统变得面向对象。\n\n## 绘制自己\n\n　　全字段封装的一个分支存在于UI构造器中。如果你不能使用存储器，你就不能在一个UI构造类中调用`getAttribute()`方法。取而代之的是类会提供一个drawYourself(…)方法。\n　　\n　　`getIdentity()`方法当然也能工作，假如他实现了Identity接口返回一个对象。这个接口必须包含`drawYourself()`方法（或者**give-me-a-Component-that-represents-your-identity**）。虽然`getIdentity`用“get”开头，但是他不是一个存储器因为他没有返回一个字段。他返回一个包含适当行为的复杂对象。甚至当我获得了一个Identity对象，我仍然不知道identity内部的细节。\n\n　　当然，`drawYourself()`策略意味着我把UI代码放入了业务逻辑。考虑下当UI表现发生变化时会发生什么事情。假设我想让一个属性以完全不同的方式来呈现，今天identity是一个名字，明天是一个名字和id，后天是一个名字、id和一张图。我把这些代码改动带来的影响限制在了一个地方。如果我有一个**give-me-a-Component-that-represents-your-identity**类，我已经将identity的表现与系统的其余部分隔离了开来。\n\n　　牢记一点，我没有把任何代码放入业务逻辑。我依据AWT或Swing框架编写UI层。这些UI代码是AWT/Swing的实现。使用抽象层来将其与子系统的业务逻辑隔离开是核心所在。我可以在不改任何代码的情况下轻松的接驳到其他绘图环境，唯一的问题是代码稍显杂乱。你可以将代码移到内部类中来相处这个问题（或者使用Facade设计模式）\n\n## JavaBeans\n\n　　你可能会反对说：“那么JavaBeans怎么办？” 怎么办？你完全可以不使用getters和setter来构造JavaBeans。BeanCustomizer,BeanInfo, 和 BeanDescriptor类都是为了这个目的而存在的。JavaBeans规范设计师们将getter/setter风格放入了规范因为他们认为当你已经学会了什么才是正确的时候，getter/setter可以让人们更容易的构造一个bean。很遗憾，没人去这样做。\n\n　　存储器仅仅是被创建来作为标记特定属性的标签之用，因为类似UI生成器之类的需要标识他们。你不被建议去自己调用这些方法。他们是为自动工具的调用准备的。这工具使用在Class类中的内省API来找到方法并且更具方法名来推断指定属性是否存在。在实践中基于内省的风格没有奏效。它反而是的代码更复杂更面向过程化。不理解数据抽象的程序员调用存储器必然导致，代码很难维护。基于这个原因，元数据特性会被包含进Java1.5。你将不必再这样变现:\n\n\tprivate int property;\n\tpublic int getProperty  (　　 ){ return property; }\n\tpublic void setProperty (int value}{ property = value; }\n\t\n将来可以这样\n\n\tprivate @property int property;\n\t\n类似于UI构造工具将使用内审API直接找到元素而不先通过测试方法名再去判断元素是否存在。因此，在有没有运行时存储器来破坏你的代码了。\n\n## 何时存储器是有用的？\n　　首先，在讨论之初我说就过如果某个存储器方法返回的是以接口为单位的实例（这个接口是被当前对象实现的）那么这个存储器就是有效的，因为接口隔离了实现类内部的倪安东。这类的方法（返回一个接口引用）不是一个普通意义上提供直接操作字段功能的“getter”方法。如果你改变了提供者的内部实现，你只要改变返回对象的定义就能适应这些变化。你依然保护了那些通过对象接口来访问的外部代码。\n\n　　其次，我认为所有的OO系统都有一个面向过程分界层。绝大多数OO程序运行在面向过程的操作系统只上并且与面向过程的数据库通讯。这些外部过程化子系统的接口是通用性质的。Java Database Connectivity(JDBC)设计者并不知道你为何目的使用数据库，所以数据库类必须设计的通用和高度灵活。一般来说，不必要的灵活性是有害的，但是对于这些API来说过度的灵活性是不可避免的。这些边界类被简单的使用存储方法加载因为设计者别无选择。\n\n　　事实上，设计者不知道用户如何调用的问题充斥着整个Java包。如果你不能预测你将如何使用类对象那么淘汰所有存储器就是困难的。受制于此，Java设计者已经做了一切他们能做的去隐藏实现。这并不是说你的代码也应该采用jdbc的设计风格。绝不应该！我们一定知道我们的类是如何被使用的，所以我们不用浪费时间去创建不必要的灵活性。\n\n## 一个设计策略\n\n　　 所以我们怎么抛弃getter和setter呢？\n\n　　 以用例为中心的OO设计过程:用户执行的有输出结果的特定任务。（登录不是一个用例因为它在问题域中缺少有用的结果输出。所以绘制一个账单是一个用例。）一个面向对象的系统实现了创建包含用例的各种场景所需的活动。实现用例的运行时对象通过向另一个对象发送消息来完成工作。当然，不是所有的消息都是等价的。如果你只是简单的构建了一个使用对象和类的面向过程的程序，那么你就不很难完成所有工作。\n\n　　1989年，Kent Beck 和 Ward Cunningharn在教授面向对象的设计课程时，曾对改变过度依赖get/set的心理做了如下的阐述：\n\n\t在教授面向对象的程序设计时最困难的是让学习者放弃那些在面向过程程序中司空见惯的全局信息获取，转而依赖类本身的信息去完成他们的任务。新手的设计充斥着全局思维：非理由的全局变量、不必要的指针以及在实现过程中对其他类不恰当的依赖。\n\n　　Cunningham发展了一套能够很好展示设计过程的教学方法:CRC卡片（类，职责，协作）。最基本的做法是做一套4x6规格的索引卡片，用来展示三个方面：\n\n* 类：类对象的名字\n* 职责：那些类可以做什么。这些职责应该专注于一个特定技术范围内\n* 协作：可与当前类对象通讯的其他类对象。这里的东西越少越好\n   \n　　CRC卡片最初的构想是基于一个假设——事情总会发生变化。\n\n　　Beck和Cunningham然后挑选一个用例，然后决定哪些对象会被要求执行这个用例做出最全面的假设。他们通常从两个类开始着手，不断的添加其他类用以实现用例。他们从班上挑选一些人来代表那些对象并发给他们一张相关的CRC卡片。如果他们需要一些给定的类对象，那么一些学生会被挑选来代表那些对象。\n\n　　然后这个班级开始根据以下规则实现用例：\n\n* 通过与其他人的沟通来完成用例包含的动作。\n* 你只能与你的协作对象进行交流。如果你必须和其他人交流，你应该交由一个能与那人交流的协作对象去完成，如果依然不行，你必须在你的CRC卡片上添加一个协作这。\n* 你不能去直接获取用来完成工作的信息。取而代之的，你必须请求拥有这些信息的对象去完成这个工作。把完成任务必须的信息传递给协作者是可以的，但是请把这些互动保持在最低限度。\n* 如果一些事情必须完成但是又没人能完成，那么创建一个新类和CRC卡片或者在已有的类和CRC卡片中添加一个职责。\n* 如果卡片写的太满，你必须创建其他的类和CRC卡片去分担一些指着。类的复杂度被4x6卡片的容量所限制。\n　　\n　　整个交流的记录就是程序的动态模型。最终完成的CRC卡片就是静态模型。通过不断的尝试和实践你可以使用这个方法解决任何问题。\n\n　　我刚刚描述的这个过程就是面向对象设计过程，尽管为适应课堂教学做了简化。一些人使用CRC卡片设计真实的程序。然而，更多的时候，设计者使用统一建模语言（UML）设计动态和静态模型。OO系统的要点是对象的通讯。如果你仔细思考，get/set方法在通讯过程是不需要的。同样的，在你开始编码之前，如果你以这种方式设计，get / set方法将不会出现在你的代码中。\n\n## 总结\n　　让我们总结一下：除非逼不得已你应该避免使用存储器因为这些方法暴露了类是如何实现的信息，从而导致你的代码变得难以维护。有时get/set方法不可避免，但是根据面向对象设计经验去掉你现在代码中99%的get/set方法是没有困难的。\n\n　　getter/setter方法往往会在代码中起到作用因为编写者使用过程思维来思考问题的，摆脱这种过程思维的最好方法是设想定义明确职责的对象之间的对话。Cunningham的CRC卡片方法是一个伟大的入门手段。","source":"_posts/why-getter-and-setter-methods-are-evil.md","raw":"---\ntitle: 为什么getter和setter方法是魔鬼 \ndate: 2017-01-10 15:19:24\ntags:\n  - Java\n  - 翻译\n  - 存储器\n  - getter\n  - setter\ncategories: Java\n\n---\n# 为什么getter和setter方法是魔鬼\n**_通过避免使用存储器来使你的代码变得更易维护_**\n\n**[原文地址](http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html)**\n\n## 前言\n\n　　我没有打算开始一个“魔鬼的步伐”系列。但一些读者请我解释为什么我在上个月的专栏文章\"[Why extends Is Evil](http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html)”中提到你应该避免使用get/set方法。\n\n　　尽管getter/setter方法在Java中是很常见的，但是他们不是特别符合面向对象的思想。事实上，他们会使你的代码变得难易维护。此外，大量getter和setter方法的出现是一个危险信号，它意味着你的程序不能被很好的符合OO思想。\n\n　　这篇文章解释了为什么你不应该使用getters和setters方法（在你能用他们的时候），并且提出一个可以帮助你跳出getter/setter误区的设计思想。\n\n## 设计的本质\n\n　　在我开始一个具有有争议标题的技术专栏前，我想澄清一些事情。\n\n　　我被一些读者在\"[Why extends Is Evil](http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html)”一文下的评论给震惊了。一些人相信我宣称面向对象不是朴素的因为extents有问题，好像这两个论点是等价的。那绝对不是我想说的，所以我要澄清一些元问题（meta-issues）。\n<!--more-->\n　　这个专栏和过去几个月的文章都在讨论设计。设计从本质上来说以一种权衡。每一个选择都有其两面性，你需要在既定标准中做出决定。好和坏不是绝对的，一个好的决定一旦换了个环境就未必如此了。\n   \n　　如果你不能理解问题的两面性，你就不能做出一个明智的选择。事实上，如果你不理解每个行动会带来的所有后果，你就完全不能进行设计。你在黑暗中蹒跚前行。在“四人帮”的《设计模式》一书中每一章节都包含“Consequences”一小结用来说明哪些情况不适用当前模式，这绝不仅仅是一种偶然。\n\n　　阐述某些语言的特性或普遍的程序设计风格（比如存取方法）有问题不等于说你决不能在任何情况下使用他们。同样的，一个特性或风格被普遍使用不意味着你也可以使用它。那些不明就里的写了许多程序并且受雇于Sun或者微软的不明就里的程序员不能魔法般的提高程序开发和设计的能力。JAVA开发包中包含了很多伟大的代码。但是同样有一部分代码我确定是他们的作者羞于承认的。\n   \n　　出于同样的原因，营销或者政治动机经常推动着设计风格。有时候程序要做了错误的决定但是企业为了宣传他们的技术多牛B，所以他们前调你现在用的方法是不太理想的。当你仅仅是因为“这事你们应该这么干”而草率的接受了某些程序实践，那么你的行为是不负责任的。许多失败的EJB工程证明了这个原则。基于EJB的技术当你正确使用时是伟大的技术，但是当你滥用它的时候也能彻底的击倒一个企业。\n\n　　我的观点是你不能盲目的写程序。你必须理解一个特性或习惯所能造成的破坏。在这情况下，你会处于一个更有利的位置去决定是否需要使用这些特性或风格。你的选择会更合理更实用。这些文章的目的是帮助你用更开阔的视野去思考你的程序。\n\n## 数据抽象\n\n　　面向对象系统一个基本的原则是不要暴露任何实现细节。这样你可以修改你的实现而不改动用户代码。所以在面向对象系统中你应该避免getter和setter方法因为他们通常会保留实现细节。\n　　\n　　让我们来看为什么，假设在你的程序中有1000次的getX()方法的调用，每一个调用都假设了一个特定类型值的返回。你必须在本地变量中储层这个返回值，并且变量的类型必须和返回类型是相匹配的。如果你需要改变对象的实现从而导致X类型的改变，那么你就摊上大麻烦了。\n　　\n　　如果X曾是int型，但现在必须是long型，你会得到1000个编译错误。如果你只是简单的将返回值强制转换成int型，代码讲被编译通过，但未必能正常工作（返回值可能被截断）。为了这一个改动你必须逐一修改1000个调用。我肯定我不愿意去做这么多工作。\n　　\n　　面向对象系统的一个基本原则是数据抽象，你应该完全隐藏一个对象是如何处理从其他模块中获得的消息。这就是为什么你应该将所有实例对象(非常量)申明为private。\n   \n　　 如果你将一个成员申明为public,那么无论类发生了什么变化这个变量都不能被改变，因为你会破坏外部代码对这个成员的使用。你不会愿意搜索1000处调用仅仅是因为你改动了那个类。\n   \n　　隐藏实现原则提供了一个快速的检验OO系统质量的测试方法：你能否把类改得面目全非，却不影响任何用户的使用？模块化的匪类是面向对象的前提，它使得程序更易维护。没有实现的隐藏其他OO特性也就无从谈起。\n　　\n　　Getter和Setter方法（也被称为存储器）和公有成员变量都是危险的。他们暴露了实现细节。如果你要改变被访问字段的类型该怎么办？你也必须改变存储器的返回类型。你在无数地方使用了这个返回值，因此你必须全部更改这些代码。我希望限制修改单个类的所带来的影响，而不是波及到整个程序。\n\n　　既然存储器违反了封装原则，你就有理由主张一个过度滥用存储器的系统不符合面向对象思想。如果你不只是为了写代码而是认真检查设计流程，你能完全摒弃存储器，这个流程至关重要。我会在后文更详尽的阐述这个问题。\n\n　　减少getter/setter方法不意味着某些数据讲不能在系统中流动。尽管如此，数据流动还是越少越好。据我的经验系统可维护性是与数据在两个对象间交互的数量成反比的。经管你可能不知道，但是你可以消除绝大多数的数据移动。\n　　\n　　通过细致的设计并且着眼于你应该干什么而不是你怎么干，你可以消除绝大的多数的getter/setter方法。不要去请求完成工作需要的信息，而是让持有相关信息的对象去完成工作。大多数存储器提供了访问代码的手段因为设计者没有认真思考动态模型：为了完成工作所需要互相发送的动态对象和消息。他们的设计工作错误的由设计类的层级（类图）开始，然后试图把那些类强塞进动态模型。这种方式从来不能奏效。要设计一个静态模型，你需要发现类与类直接按的关联，这些关联完全与信息流相符合。一个联系存在与两个类之间，当且仅当有一个类的对象向其他类的对象发送了消息。静态模型的主要目的就是为你的动态模型捕捉这些关联。\n\n　　没有一个清晰的动态模型的定义，你只能猜想你会怎么使用一个类的对象。因此，存储方法会被大量绑定到模型上，你必须提供经可能多的存储方法因为你根本不能预测是否会用到他们。这类设计完全靠猜的策略是效率低下的。你把时间浪费在了写无用的方法上（或者给类加了不必要的能力）。\n\n　　存储器也是习惯思维的产物。当面向过程的程序员门接触到了Java，他们试图开始构建相似的代码。面向过程语言没有类，但他们有C结构体（struct,你可以把他看做没有方法的类）。然后理所当然地开始模仿设计结构体的方式去设计一个类，这个类除了公有成员没有其他的东西。这些面向过程的程序员们在其他一些地方知道了成员应该是私有的，然后他们把成员改成了私有并且提供了共有的存储方法。其实他们只是让共有调用变得复杂，而并没有让系统变得面向对象。\n\n## 绘制自己\n\n　　全字段封装的一个分支存在于UI构造器中。如果你不能使用存储器，你就不能在一个UI构造类中调用`getAttribute()`方法。取而代之的是类会提供一个drawYourself(…)方法。\n　　\n　　`getIdentity()`方法当然也能工作，假如他实现了Identity接口返回一个对象。这个接口必须包含`drawYourself()`方法（或者**give-me-a-Component-that-represents-your-identity**）。虽然`getIdentity`用“get”开头，但是他不是一个存储器因为他没有返回一个字段。他返回一个包含适当行为的复杂对象。甚至当我获得了一个Identity对象，我仍然不知道identity内部的细节。\n\n　　当然，`drawYourself()`策略意味着我把UI代码放入了业务逻辑。考虑下当UI表现发生变化时会发生什么事情。假设我想让一个属性以完全不同的方式来呈现，今天identity是一个名字，明天是一个名字和id，后天是一个名字、id和一张图。我把这些代码改动带来的影响限制在了一个地方。如果我有一个**give-me-a-Component-that-represents-your-identity**类，我已经将identity的表现与系统的其余部分隔离了开来。\n\n　　牢记一点，我没有把任何代码放入业务逻辑。我依据AWT或Swing框架编写UI层。这些UI代码是AWT/Swing的实现。使用抽象层来将其与子系统的业务逻辑隔离开是核心所在。我可以在不改任何代码的情况下轻松的接驳到其他绘图环境，唯一的问题是代码稍显杂乱。你可以将代码移到内部类中来相处这个问题（或者使用Facade设计模式）\n\n## JavaBeans\n\n　　你可能会反对说：“那么JavaBeans怎么办？” 怎么办？你完全可以不使用getters和setter来构造JavaBeans。BeanCustomizer,BeanInfo, 和 BeanDescriptor类都是为了这个目的而存在的。JavaBeans规范设计师们将getter/setter风格放入了规范因为他们认为当你已经学会了什么才是正确的时候，getter/setter可以让人们更容易的构造一个bean。很遗憾，没人去这样做。\n\n　　存储器仅仅是被创建来作为标记特定属性的标签之用，因为类似UI生成器之类的需要标识他们。你不被建议去自己调用这些方法。他们是为自动工具的调用准备的。这工具使用在Class类中的内省API来找到方法并且更具方法名来推断指定属性是否存在。在实践中基于内省的风格没有奏效。它反而是的代码更复杂更面向过程化。不理解数据抽象的程序员调用存储器必然导致，代码很难维护。基于这个原因，元数据特性会被包含进Java1.5。你将不必再这样变现:\n\n\tprivate int property;\n\tpublic int getProperty  (　　 ){ return property; }\n\tpublic void setProperty (int value}{ property = value; }\n\t\n将来可以这样\n\n\tprivate @property int property;\n\t\n类似于UI构造工具将使用内审API直接找到元素而不先通过测试方法名再去判断元素是否存在。因此，在有没有运行时存储器来破坏你的代码了。\n\n## 何时存储器是有用的？\n　　首先，在讨论之初我说就过如果某个存储器方法返回的是以接口为单位的实例（这个接口是被当前对象实现的）那么这个存储器就是有效的，因为接口隔离了实现类内部的倪安东。这类的方法（返回一个接口引用）不是一个普通意义上提供直接操作字段功能的“getter”方法。如果你改变了提供者的内部实现，你只要改变返回对象的定义就能适应这些变化。你依然保护了那些通过对象接口来访问的外部代码。\n\n　　其次，我认为所有的OO系统都有一个面向过程分界层。绝大多数OO程序运行在面向过程的操作系统只上并且与面向过程的数据库通讯。这些外部过程化子系统的接口是通用性质的。Java Database Connectivity(JDBC)设计者并不知道你为何目的使用数据库，所以数据库类必须设计的通用和高度灵活。一般来说，不必要的灵活性是有害的，但是对于这些API来说过度的灵活性是不可避免的。这些边界类被简单的使用存储方法加载因为设计者别无选择。\n\n　　事实上，设计者不知道用户如何调用的问题充斥着整个Java包。如果你不能预测你将如何使用类对象那么淘汰所有存储器就是困难的。受制于此，Java设计者已经做了一切他们能做的去隐藏实现。这并不是说你的代码也应该采用jdbc的设计风格。绝不应该！我们一定知道我们的类是如何被使用的，所以我们不用浪费时间去创建不必要的灵活性。\n\n## 一个设计策略\n\n　　 所以我们怎么抛弃getter和setter呢？\n\n　　 以用例为中心的OO设计过程:用户执行的有输出结果的特定任务。（登录不是一个用例因为它在问题域中缺少有用的结果输出。所以绘制一个账单是一个用例。）一个面向对象的系统实现了创建包含用例的各种场景所需的活动。实现用例的运行时对象通过向另一个对象发送消息来完成工作。当然，不是所有的消息都是等价的。如果你只是简单的构建了一个使用对象和类的面向过程的程序，那么你就不很难完成所有工作。\n\n　　1989年，Kent Beck 和 Ward Cunningharn在教授面向对象的设计课程时，曾对改变过度依赖get/set的心理做了如下的阐述：\n\n\t在教授面向对象的程序设计时最困难的是让学习者放弃那些在面向过程程序中司空见惯的全局信息获取，转而依赖类本身的信息去完成他们的任务。新手的设计充斥着全局思维：非理由的全局变量、不必要的指针以及在实现过程中对其他类不恰当的依赖。\n\n　　Cunningham发展了一套能够很好展示设计过程的教学方法:CRC卡片（类，职责，协作）。最基本的做法是做一套4x6规格的索引卡片，用来展示三个方面：\n\n* 类：类对象的名字\n* 职责：那些类可以做什么。这些职责应该专注于一个特定技术范围内\n* 协作：可与当前类对象通讯的其他类对象。这里的东西越少越好\n   \n　　CRC卡片最初的构想是基于一个假设——事情总会发生变化。\n\n　　Beck和Cunningham然后挑选一个用例，然后决定哪些对象会被要求执行这个用例做出最全面的假设。他们通常从两个类开始着手，不断的添加其他类用以实现用例。他们从班上挑选一些人来代表那些对象并发给他们一张相关的CRC卡片。如果他们需要一些给定的类对象，那么一些学生会被挑选来代表那些对象。\n\n　　然后这个班级开始根据以下规则实现用例：\n\n* 通过与其他人的沟通来完成用例包含的动作。\n* 你只能与你的协作对象进行交流。如果你必须和其他人交流，你应该交由一个能与那人交流的协作对象去完成，如果依然不行，你必须在你的CRC卡片上添加一个协作这。\n* 你不能去直接获取用来完成工作的信息。取而代之的，你必须请求拥有这些信息的对象去完成这个工作。把完成任务必须的信息传递给协作者是可以的，但是请把这些互动保持在最低限度。\n* 如果一些事情必须完成但是又没人能完成，那么创建一个新类和CRC卡片或者在已有的类和CRC卡片中添加一个职责。\n* 如果卡片写的太满，你必须创建其他的类和CRC卡片去分担一些指着。类的复杂度被4x6卡片的容量所限制。\n　　\n　　整个交流的记录就是程序的动态模型。最终完成的CRC卡片就是静态模型。通过不断的尝试和实践你可以使用这个方法解决任何问题。\n\n　　我刚刚描述的这个过程就是面向对象设计过程，尽管为适应课堂教学做了简化。一些人使用CRC卡片设计真实的程序。然而，更多的时候，设计者使用统一建模语言（UML）设计动态和静态模型。OO系统的要点是对象的通讯。如果你仔细思考，get/set方法在通讯过程是不需要的。同样的，在你开始编码之前，如果你以这种方式设计，get / set方法将不会出现在你的代码中。\n\n## 总结\n　　让我们总结一下：除非逼不得已你应该避免使用存储器因为这些方法暴露了类是如何实现的信息，从而导致你的代码变得难以维护。有时get/set方法不可避免，但是根据面向对象设计经验去掉你现在代码中99%的get/set方法是没有困难的。\n\n　　getter/setter方法往往会在代码中起到作用因为编写者使用过程思维来思考问题的，摆脱这种过程思维的最好方法是设想定义明确职责的对象之间的对话。Cunningham的CRC卡片方法是一个伟大的入门手段。","slug":"why-getter-and-setter-methods-are-evil","published":1,"updated":"2017-07-06T08:52:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj4tf869g00066b6nagyrw8ql","content":"<h1 id=\"为什么getter和setter方法是魔鬼\"><a href=\"#为什么getter和setter方法是魔鬼\" class=\"headerlink\" title=\"为什么getter和setter方法是魔鬼\"></a>为什么getter和setter方法是魔鬼</h1><p><strong><em>通过避免使用存储器来使你的代码变得更易维护</em></strong></p>\n<p><strong><a href=\"http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html\" target=\"_blank\" rel=\"external\">原文地址</a></strong></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>　　我没有打算开始一个“魔鬼的步伐”系列。但一些读者请我解释为什么我在上个月的专栏文章”<a href=\"http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html\" target=\"_blank\" rel=\"external\">Why extends Is Evil</a>”中提到你应该避免使用get/set方法。</p>\n<p>　　尽管getter/setter方法在Java中是很常见的，但是他们不是特别符合面向对象的思想。事实上，他们会使你的代码变得难易维护。此外，大量getter和setter方法的出现是一个危险信号，它意味着你的程序不能被很好的符合OO思想。</p>\n<p>　　这篇文章解释了为什么你不应该使用getters和setters方法（在你能用他们的时候），并且提出一个可以帮助你跳出getter/setter误区的设计思想。</p>\n<h2 id=\"设计的本质\"><a href=\"#设计的本质\" class=\"headerlink\" title=\"设计的本质\"></a>设计的本质</h2><p>　　在我开始一个具有有争议标题的技术专栏前，我想澄清一些事情。</p>\n<p>　　我被一些读者在”<a href=\"http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html\" target=\"_blank\" rel=\"external\">Why extends Is Evil</a>”一文下的评论给震惊了。一些人相信我宣称面向对象不是朴素的因为extents有问题，好像这两个论点是等价的。那绝对不是我想说的，所以我要澄清一些元问题（meta-issues）。<br><a id=\"more\"></a><br>　　这个专栏和过去几个月的文章都在讨论设计。设计从本质上来说以一种权衡。每一个选择都有其两面性，你需要在既定标准中做出决定。好和坏不是绝对的，一个好的决定一旦换了个环境就未必如此了。</p>\n<p>　　如果你不能理解问题的两面性，你就不能做出一个明智的选择。事实上，如果你不理解每个行动会带来的所有后果，你就完全不能进行设计。你在黑暗中蹒跚前行。在“四人帮”的《设计模式》一书中每一章节都包含“Consequences”一小结用来说明哪些情况不适用当前模式，这绝不仅仅是一种偶然。</p>\n<p>　　阐述某些语言的特性或普遍的程序设计风格（比如存取方法）有问题不等于说你决不能在任何情况下使用他们。同样的，一个特性或风格被普遍使用不意味着你也可以使用它。那些不明就里的写了许多程序并且受雇于Sun或者微软的不明就里的程序员不能魔法般的提高程序开发和设计的能力。JAVA开发包中包含了很多伟大的代码。但是同样有一部分代码我确定是他们的作者羞于承认的。</p>\n<p>　　出于同样的原因，营销或者政治动机经常推动着设计风格。有时候程序要做了错误的决定但是企业为了宣传他们的技术多牛B，所以他们前调你现在用的方法是不太理想的。当你仅仅是因为“这事你们应该这么干”而草率的接受了某些程序实践，那么你的行为是不负责任的。许多失败的EJB工程证明了这个原则。基于EJB的技术当你正确使用时是伟大的技术，但是当你滥用它的时候也能彻底的击倒一个企业。</p>\n<p>　　我的观点是你不能盲目的写程序。你必须理解一个特性或习惯所能造成的破坏。在这情况下，你会处于一个更有利的位置去决定是否需要使用这些特性或风格。你的选择会更合理更实用。这些文章的目的是帮助你用更开阔的视野去思考你的程序。</p>\n<h2 id=\"数据抽象\"><a href=\"#数据抽象\" class=\"headerlink\" title=\"数据抽象\"></a>数据抽象</h2><p>　　面向对象系统一个基本的原则是不要暴露任何实现细节。这样你可以修改你的实现而不改动用户代码。所以在面向对象系统中你应该避免getter和setter方法因为他们通常会保留实现细节。<br>　　<br>　　让我们来看为什么，假设在你的程序中有1000次的getX()方法的调用，每一个调用都假设了一个特定类型值的返回。你必须在本地变量中储层这个返回值，并且变量的类型必须和返回类型是相匹配的。如果你需要改变对象的实现从而导致X类型的改变，那么你就摊上大麻烦了。<br>　　<br>　　如果X曾是int型，但现在必须是long型，你会得到1000个编译错误。如果你只是简单的将返回值强制转换成int型，代码讲被编译通过，但未必能正常工作（返回值可能被截断）。为了这一个改动你必须逐一修改1000个调用。我肯定我不愿意去做这么多工作。<br>　　<br>　　面向对象系统的一个基本原则是数据抽象，你应该完全隐藏一个对象是如何处理从其他模块中获得的消息。这就是为什么你应该将所有实例对象(非常量)申明为private。</p>\n<p>　　 如果你将一个成员申明为public,那么无论类发生了什么变化这个变量都不能被改变，因为你会破坏外部代码对这个成员的使用。你不会愿意搜索1000处调用仅仅是因为你改动了那个类。</p>\n<p>　　隐藏实现原则提供了一个快速的检验OO系统质量的测试方法：你能否把类改得面目全非，却不影响任何用户的使用？模块化的匪类是面向对象的前提，它使得程序更易维护。没有实现的隐藏其他OO特性也就无从谈起。<br>　　<br>　　Getter和Setter方法（也被称为存储器）和公有成员变量都是危险的。他们暴露了实现细节。如果你要改变被访问字段的类型该怎么办？你也必须改变存储器的返回类型。你在无数地方使用了这个返回值，因此你必须全部更改这些代码。我希望限制修改单个类的所带来的影响，而不是波及到整个程序。</p>\n<p>　　既然存储器违反了封装原则，你就有理由主张一个过度滥用存储器的系统不符合面向对象思想。如果你不只是为了写代码而是认真检查设计流程，你能完全摒弃存储器，这个流程至关重要。我会在后文更详尽的阐述这个问题。</p>\n<p>　　减少getter/setter方法不意味着某些数据讲不能在系统中流动。尽管如此，数据流动还是越少越好。据我的经验系统可维护性是与数据在两个对象间交互的数量成反比的。经管你可能不知道，但是你可以消除绝大多数的数据移动。<br>　　<br>　　通过细致的设计并且着眼于你应该干什么而不是你怎么干，你可以消除绝大的多数的getter/setter方法。不要去请求完成工作需要的信息，而是让持有相关信息的对象去完成工作。大多数存储器提供了访问代码的手段因为设计者没有认真思考动态模型：为了完成工作所需要互相发送的动态对象和消息。他们的设计工作错误的由设计类的层级（类图）开始，然后试图把那些类强塞进动态模型。这种方式从来不能奏效。要设计一个静态模型，你需要发现类与类直接按的关联，这些关联完全与信息流相符合。一个联系存在与两个类之间，当且仅当有一个类的对象向其他类的对象发送了消息。静态模型的主要目的就是为你的动态模型捕捉这些关联。</p>\n<p>　　没有一个清晰的动态模型的定义，你只能猜想你会怎么使用一个类的对象。因此，存储方法会被大量绑定到模型上，你必须提供经可能多的存储方法因为你根本不能预测是否会用到他们。这类设计完全靠猜的策略是效率低下的。你把时间浪费在了写无用的方法上（或者给类加了不必要的能力）。</p>\n<p>　　存储器也是习惯思维的产物。当面向过程的程序员门接触到了Java，他们试图开始构建相似的代码。面向过程语言没有类，但他们有C结构体（struct,你可以把他看做没有方法的类）。然后理所当然地开始模仿设计结构体的方式去设计一个类，这个类除了公有成员没有其他的东西。这些面向过程的程序员们在其他一些地方知道了成员应该是私有的，然后他们把成员改成了私有并且提供了共有的存储方法。其实他们只是让共有调用变得复杂，而并没有让系统变得面向对象。</p>\n<h2 id=\"绘制自己\"><a href=\"#绘制自己\" class=\"headerlink\" title=\"绘制自己\"></a>绘制自己</h2><p>　　全字段封装的一个分支存在于UI构造器中。如果你不能使用存储器，你就不能在一个UI构造类中调用<code>getAttribute()</code>方法。取而代之的是类会提供一个drawYourself(…)方法。<br>　　<br>　　<code>getIdentity()</code>方法当然也能工作，假如他实现了Identity接口返回一个对象。这个接口必须包含<code>drawYourself()</code>方法（或者<strong>give-me-a-Component-that-represents-your-identity</strong>）。虽然<code>getIdentity</code>用“get”开头，但是他不是一个存储器因为他没有返回一个字段。他返回一个包含适当行为的复杂对象。甚至当我获得了一个Identity对象，我仍然不知道identity内部的细节。</p>\n<p>　　当然，<code>drawYourself()</code>策略意味着我把UI代码放入了业务逻辑。考虑下当UI表现发生变化时会发生什么事情。假设我想让一个属性以完全不同的方式来呈现，今天identity是一个名字，明天是一个名字和id，后天是一个名字、id和一张图。我把这些代码改动带来的影响限制在了一个地方。如果我有一个<strong>give-me-a-Component-that-represents-your-identity</strong>类，我已经将identity的表现与系统的其余部分隔离了开来。</p>\n<p>　　牢记一点，我没有把任何代码放入业务逻辑。我依据AWT或Swing框架编写UI层。这些UI代码是AWT/Swing的实现。使用抽象层来将其与子系统的业务逻辑隔离开是核心所在。我可以在不改任何代码的情况下轻松的接驳到其他绘图环境，唯一的问题是代码稍显杂乱。你可以将代码移到内部类中来相处这个问题（或者使用Facade设计模式）</p>\n<h2 id=\"JavaBeans\"><a href=\"#JavaBeans\" class=\"headerlink\" title=\"JavaBeans\"></a>JavaBeans</h2><p>　　你可能会反对说：“那么JavaBeans怎么办？” 怎么办？你完全可以不使用getters和setter来构造JavaBeans。BeanCustomizer,BeanInfo, 和 BeanDescriptor类都是为了这个目的而存在的。JavaBeans规范设计师们将getter/setter风格放入了规范因为他们认为当你已经学会了什么才是正确的时候，getter/setter可以让人们更容易的构造一个bean。很遗憾，没人去这样做。</p>\n<p>　　存储器仅仅是被创建来作为标记特定属性的标签之用，因为类似UI生成器之类的需要标识他们。你不被建议去自己调用这些方法。他们是为自动工具的调用准备的。这工具使用在Class类中的内省API来找到方法并且更具方法名来推断指定属性是否存在。在实践中基于内省的风格没有奏效。它反而是的代码更复杂更面向过程化。不理解数据抽象的程序员调用存储器必然导致，代码很难维护。基于这个原因，元数据特性会被包含进Java1.5。你将不必再这样变现:</p>\n<pre><code>private int property;\npublic int getProperty  (　　 ){ return property; }\npublic void setProperty (int value}{ property = value; }\n</code></pre><p>将来可以这样</p>\n<pre><code>private @property int property;\n</code></pre><p>类似于UI构造工具将使用内审API直接找到元素而不先通过测试方法名再去判断元素是否存在。因此，在有没有运行时存储器来破坏你的代码了。</p>\n<h2 id=\"何时存储器是有用的？\"><a href=\"#何时存储器是有用的？\" class=\"headerlink\" title=\"何时存储器是有用的？\"></a>何时存储器是有用的？</h2><p>　　首先，在讨论之初我说就过如果某个存储器方法返回的是以接口为单位的实例（这个接口是被当前对象实现的）那么这个存储器就是有效的，因为接口隔离了实现类内部的倪安东。这类的方法（返回一个接口引用）不是一个普通意义上提供直接操作字段功能的“getter”方法。如果你改变了提供者的内部实现，你只要改变返回对象的定义就能适应这些变化。你依然保护了那些通过对象接口来访问的外部代码。</p>\n<p>　　其次，我认为所有的OO系统都有一个面向过程分界层。绝大多数OO程序运行在面向过程的操作系统只上并且与面向过程的数据库通讯。这些外部过程化子系统的接口是通用性质的。Java Database Connectivity(JDBC)设计者并不知道你为何目的使用数据库，所以数据库类必须设计的通用和高度灵活。一般来说，不必要的灵活性是有害的，但是对于这些API来说过度的灵活性是不可避免的。这些边界类被简单的使用存储方法加载因为设计者别无选择。</p>\n<p>　　事实上，设计者不知道用户如何调用的问题充斥着整个Java包。如果你不能预测你将如何使用类对象那么淘汰所有存储器就是困难的。受制于此，Java设计者已经做了一切他们能做的去隐藏实现。这并不是说你的代码也应该采用jdbc的设计风格。绝不应该！我们一定知道我们的类是如何被使用的，所以我们不用浪费时间去创建不必要的灵活性。</p>\n<h2 id=\"一个设计策略\"><a href=\"#一个设计策略\" class=\"headerlink\" title=\"一个设计策略\"></a>一个设计策略</h2><p>　　 所以我们怎么抛弃getter和setter呢？</p>\n<p>　　 以用例为中心的OO设计过程:用户执行的有输出结果的特定任务。（登录不是一个用例因为它在问题域中缺少有用的结果输出。所以绘制一个账单是一个用例。）一个面向对象的系统实现了创建包含用例的各种场景所需的活动。实现用例的运行时对象通过向另一个对象发送消息来完成工作。当然，不是所有的消息都是等价的。如果你只是简单的构建了一个使用对象和类的面向过程的程序，那么你就不很难完成所有工作。</p>\n<p>　　1989年，Kent Beck 和 Ward Cunningharn在教授面向对象的设计课程时，曾对改变过度依赖get/set的心理做了如下的阐述：</p>\n<pre><code>在教授面向对象的程序设计时最困难的是让学习者放弃那些在面向过程程序中司空见惯的全局信息获取，转而依赖类本身的信息去完成他们的任务。新手的设计充斥着全局思维：非理由的全局变量、不必要的指针以及在实现过程中对其他类不恰当的依赖。\n</code></pre><p>　　Cunningham发展了一套能够很好展示设计过程的教学方法:CRC卡片（类，职责，协作）。最基本的做法是做一套4x6规格的索引卡片，用来展示三个方面：</p>\n<ul>\n<li>类：类对象的名字</li>\n<li>职责：那些类可以做什么。这些职责应该专注于一个特定技术范围内</li>\n<li>协作：可与当前类对象通讯的其他类对象。这里的东西越少越好</li>\n</ul>\n<p>　　CRC卡片最初的构想是基于一个假设——事情总会发生变化。</p>\n<p>　　Beck和Cunningham然后挑选一个用例，然后决定哪些对象会被要求执行这个用例做出最全面的假设。他们通常从两个类开始着手，不断的添加其他类用以实现用例。他们从班上挑选一些人来代表那些对象并发给他们一张相关的CRC卡片。如果他们需要一些给定的类对象，那么一些学生会被挑选来代表那些对象。</p>\n<p>　　然后这个班级开始根据以下规则实现用例：</p>\n<ul>\n<li>通过与其他人的沟通来完成用例包含的动作。</li>\n<li>你只能与你的协作对象进行交流。如果你必须和其他人交流，你应该交由一个能与那人交流的协作对象去完成，如果依然不行，你必须在你的CRC卡片上添加一个协作这。</li>\n<li>你不能去直接获取用来完成工作的信息。取而代之的，你必须请求拥有这些信息的对象去完成这个工作。把完成任务必须的信息传递给协作者是可以的，但是请把这些互动保持在最低限度。</li>\n<li>如果一些事情必须完成但是又没人能完成，那么创建一个新类和CRC卡片或者在已有的类和CRC卡片中添加一个职责。</li>\n<li>如果卡片写的太满，你必须创建其他的类和CRC卡片去分担一些指着。类的复杂度被4x6卡片的容量所限制。<br>　　<br>　　整个交流的记录就是程序的动态模型。最终完成的CRC卡片就是静态模型。通过不断的尝试和实践你可以使用这个方法解决任何问题。</li>\n</ul>\n<p>　　我刚刚描述的这个过程就是面向对象设计过程，尽管为适应课堂教学做了简化。一些人使用CRC卡片设计真实的程序。然而，更多的时候，设计者使用统一建模语言（UML）设计动态和静态模型。OO系统的要点是对象的通讯。如果你仔细思考，get/set方法在通讯过程是不需要的。同样的，在你开始编码之前，如果你以这种方式设计，get / set方法将不会出现在你的代码中。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　　让我们总结一下：除非逼不得已你应该避免使用存储器因为这些方法暴露了类是如何实现的信息，从而导致你的代码变得难以维护。有时get/set方法不可避免，但是根据面向对象设计经验去掉你现在代码中99%的get/set方法是没有困难的。</p>\n<p>　　getter/setter方法往往会在代码中起到作用因为编写者使用过程思维来思考问题的，摆脱这种过程思维的最好方法是设想定义明确职责的对象之间的对话。Cunningham的CRC卡片方法是一个伟大的入门手段。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"为什么getter和setter方法是魔鬼\"><a href=\"#为什么getter和setter方法是魔鬼\" class=\"headerlink\" title=\"为什么getter和setter方法是魔鬼\"></a>为什么getter和setter方法是魔鬼</h1><p><strong><em>通过避免使用存储器来使你的代码变得更易维护</em></strong></p>\n<p><strong><a href=\"http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html\" target=\"_blank\" rel=\"external\">原文地址</a></strong></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>　　我没有打算开始一个“魔鬼的步伐”系列。但一些读者请我解释为什么我在上个月的专栏文章”<a href=\"http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html\" target=\"_blank\" rel=\"external\">Why extends Is Evil</a>”中提到你应该避免使用get/set方法。</p>\n<p>　　尽管getter/setter方法在Java中是很常见的，但是他们不是特别符合面向对象的思想。事实上，他们会使你的代码变得难易维护。此外，大量getter和setter方法的出现是一个危险信号，它意味着你的程序不能被很好的符合OO思想。</p>\n<p>　　这篇文章解释了为什么你不应该使用getters和setters方法（在你能用他们的时候），并且提出一个可以帮助你跳出getter/setter误区的设计思想。</p>\n<h2 id=\"设计的本质\"><a href=\"#设计的本质\" class=\"headerlink\" title=\"设计的本质\"></a>设计的本质</h2><p>　　在我开始一个具有有争议标题的技术专栏前，我想澄清一些事情。</p>\n<p>　　我被一些读者在”<a href=\"http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html\" target=\"_blank\" rel=\"external\">Why extends Is Evil</a>”一文下的评论给震惊了。一些人相信我宣称面向对象不是朴素的因为extents有问题，好像这两个论点是等价的。那绝对不是我想说的，所以我要澄清一些元问题（meta-issues）。<br></p>","more":"<br>　　这个专栏和过去几个月的文章都在讨论设计。设计从本质上来说以一种权衡。每一个选择都有其两面性，你需要在既定标准中做出决定。好和坏不是绝对的，一个好的决定一旦换了个环境就未必如此了。<p></p>\n<p>　　如果你不能理解问题的两面性，你就不能做出一个明智的选择。事实上，如果你不理解每个行动会带来的所有后果，你就完全不能进行设计。你在黑暗中蹒跚前行。在“四人帮”的《设计模式》一书中每一章节都包含“Consequences”一小结用来说明哪些情况不适用当前模式，这绝不仅仅是一种偶然。</p>\n<p>　　阐述某些语言的特性或普遍的程序设计风格（比如存取方法）有问题不等于说你决不能在任何情况下使用他们。同样的，一个特性或风格被普遍使用不意味着你也可以使用它。那些不明就里的写了许多程序并且受雇于Sun或者微软的不明就里的程序员不能魔法般的提高程序开发和设计的能力。JAVA开发包中包含了很多伟大的代码。但是同样有一部分代码我确定是他们的作者羞于承认的。</p>\n<p>　　出于同样的原因，营销或者政治动机经常推动着设计风格。有时候程序要做了错误的决定但是企业为了宣传他们的技术多牛B，所以他们前调你现在用的方法是不太理想的。当你仅仅是因为“这事你们应该这么干”而草率的接受了某些程序实践，那么你的行为是不负责任的。许多失败的EJB工程证明了这个原则。基于EJB的技术当你正确使用时是伟大的技术，但是当你滥用它的时候也能彻底的击倒一个企业。</p>\n<p>　　我的观点是你不能盲目的写程序。你必须理解一个特性或习惯所能造成的破坏。在这情况下，你会处于一个更有利的位置去决定是否需要使用这些特性或风格。你的选择会更合理更实用。这些文章的目的是帮助你用更开阔的视野去思考你的程序。</p>\n<h2 id=\"数据抽象\"><a href=\"#数据抽象\" class=\"headerlink\" title=\"数据抽象\"></a>数据抽象</h2><p>　　面向对象系统一个基本的原则是不要暴露任何实现细节。这样你可以修改你的实现而不改动用户代码。所以在面向对象系统中你应该避免getter和setter方法因为他们通常会保留实现细节。<br>　　<br>　　让我们来看为什么，假设在你的程序中有1000次的getX()方法的调用，每一个调用都假设了一个特定类型值的返回。你必须在本地变量中储层这个返回值，并且变量的类型必须和返回类型是相匹配的。如果你需要改变对象的实现从而导致X类型的改变，那么你就摊上大麻烦了。<br>　　<br>　　如果X曾是int型，但现在必须是long型，你会得到1000个编译错误。如果你只是简单的将返回值强制转换成int型，代码讲被编译通过，但未必能正常工作（返回值可能被截断）。为了这一个改动你必须逐一修改1000个调用。我肯定我不愿意去做这么多工作。<br>　　<br>　　面向对象系统的一个基本原则是数据抽象，你应该完全隐藏一个对象是如何处理从其他模块中获得的消息。这就是为什么你应该将所有实例对象(非常量)申明为private。</p>\n<p>　　 如果你将一个成员申明为public,那么无论类发生了什么变化这个变量都不能被改变，因为你会破坏外部代码对这个成员的使用。你不会愿意搜索1000处调用仅仅是因为你改动了那个类。</p>\n<p>　　隐藏实现原则提供了一个快速的检验OO系统质量的测试方法：你能否把类改得面目全非，却不影响任何用户的使用？模块化的匪类是面向对象的前提，它使得程序更易维护。没有实现的隐藏其他OO特性也就无从谈起。<br>　　<br>　　Getter和Setter方法（也被称为存储器）和公有成员变量都是危险的。他们暴露了实现细节。如果你要改变被访问字段的类型该怎么办？你也必须改变存储器的返回类型。你在无数地方使用了这个返回值，因此你必须全部更改这些代码。我希望限制修改单个类的所带来的影响，而不是波及到整个程序。</p>\n<p>　　既然存储器违反了封装原则，你就有理由主张一个过度滥用存储器的系统不符合面向对象思想。如果你不只是为了写代码而是认真检查设计流程，你能完全摒弃存储器，这个流程至关重要。我会在后文更详尽的阐述这个问题。</p>\n<p>　　减少getter/setter方法不意味着某些数据讲不能在系统中流动。尽管如此，数据流动还是越少越好。据我的经验系统可维护性是与数据在两个对象间交互的数量成反比的。经管你可能不知道，但是你可以消除绝大多数的数据移动。<br>　　<br>　　通过细致的设计并且着眼于你应该干什么而不是你怎么干，你可以消除绝大的多数的getter/setter方法。不要去请求完成工作需要的信息，而是让持有相关信息的对象去完成工作。大多数存储器提供了访问代码的手段因为设计者没有认真思考动态模型：为了完成工作所需要互相发送的动态对象和消息。他们的设计工作错误的由设计类的层级（类图）开始，然后试图把那些类强塞进动态模型。这种方式从来不能奏效。要设计一个静态模型，你需要发现类与类直接按的关联，这些关联完全与信息流相符合。一个联系存在与两个类之间，当且仅当有一个类的对象向其他类的对象发送了消息。静态模型的主要目的就是为你的动态模型捕捉这些关联。</p>\n<p>　　没有一个清晰的动态模型的定义，你只能猜想你会怎么使用一个类的对象。因此，存储方法会被大量绑定到模型上，你必须提供经可能多的存储方法因为你根本不能预测是否会用到他们。这类设计完全靠猜的策略是效率低下的。你把时间浪费在了写无用的方法上（或者给类加了不必要的能力）。</p>\n<p>　　存储器也是习惯思维的产物。当面向过程的程序员门接触到了Java，他们试图开始构建相似的代码。面向过程语言没有类，但他们有C结构体（struct,你可以把他看做没有方法的类）。然后理所当然地开始模仿设计结构体的方式去设计一个类，这个类除了公有成员没有其他的东西。这些面向过程的程序员们在其他一些地方知道了成员应该是私有的，然后他们把成员改成了私有并且提供了共有的存储方法。其实他们只是让共有调用变得复杂，而并没有让系统变得面向对象。</p>\n<h2 id=\"绘制自己\"><a href=\"#绘制自己\" class=\"headerlink\" title=\"绘制自己\"></a>绘制自己</h2><p>　　全字段封装的一个分支存在于UI构造器中。如果你不能使用存储器，你就不能在一个UI构造类中调用<code>getAttribute()</code>方法。取而代之的是类会提供一个drawYourself(…)方法。<br>　　<br>　　<code>getIdentity()</code>方法当然也能工作，假如他实现了Identity接口返回一个对象。这个接口必须包含<code>drawYourself()</code>方法（或者<strong>give-me-a-Component-that-represents-your-identity</strong>）。虽然<code>getIdentity</code>用“get”开头，但是他不是一个存储器因为他没有返回一个字段。他返回一个包含适当行为的复杂对象。甚至当我获得了一个Identity对象，我仍然不知道identity内部的细节。</p>\n<p>　　当然，<code>drawYourself()</code>策略意味着我把UI代码放入了业务逻辑。考虑下当UI表现发生变化时会发生什么事情。假设我想让一个属性以完全不同的方式来呈现，今天identity是一个名字，明天是一个名字和id，后天是一个名字、id和一张图。我把这些代码改动带来的影响限制在了一个地方。如果我有一个<strong>give-me-a-Component-that-represents-your-identity</strong>类，我已经将identity的表现与系统的其余部分隔离了开来。</p>\n<p>　　牢记一点，我没有把任何代码放入业务逻辑。我依据AWT或Swing框架编写UI层。这些UI代码是AWT/Swing的实现。使用抽象层来将其与子系统的业务逻辑隔离开是核心所在。我可以在不改任何代码的情况下轻松的接驳到其他绘图环境，唯一的问题是代码稍显杂乱。你可以将代码移到内部类中来相处这个问题（或者使用Facade设计模式）</p>\n<h2 id=\"JavaBeans\"><a href=\"#JavaBeans\" class=\"headerlink\" title=\"JavaBeans\"></a>JavaBeans</h2><p>　　你可能会反对说：“那么JavaBeans怎么办？” 怎么办？你完全可以不使用getters和setter来构造JavaBeans。BeanCustomizer,BeanInfo, 和 BeanDescriptor类都是为了这个目的而存在的。JavaBeans规范设计师们将getter/setter风格放入了规范因为他们认为当你已经学会了什么才是正确的时候，getter/setter可以让人们更容易的构造一个bean。很遗憾，没人去这样做。</p>\n<p>　　存储器仅仅是被创建来作为标记特定属性的标签之用，因为类似UI生成器之类的需要标识他们。你不被建议去自己调用这些方法。他们是为自动工具的调用准备的。这工具使用在Class类中的内省API来找到方法并且更具方法名来推断指定属性是否存在。在实践中基于内省的风格没有奏效。它反而是的代码更复杂更面向过程化。不理解数据抽象的程序员调用存储器必然导致，代码很难维护。基于这个原因，元数据特性会被包含进Java1.5。你将不必再这样变现:</p>\n<pre><code>private int property;\npublic int getProperty  (　　 ){ return property; }\npublic void setProperty (int value}{ property = value; }\n</code></pre><p>将来可以这样</p>\n<pre><code>private @property int property;\n</code></pre><p>类似于UI构造工具将使用内审API直接找到元素而不先通过测试方法名再去判断元素是否存在。因此，在有没有运行时存储器来破坏你的代码了。</p>\n<h2 id=\"何时存储器是有用的？\"><a href=\"#何时存储器是有用的？\" class=\"headerlink\" title=\"何时存储器是有用的？\"></a>何时存储器是有用的？</h2><p>　　首先，在讨论之初我说就过如果某个存储器方法返回的是以接口为单位的实例（这个接口是被当前对象实现的）那么这个存储器就是有效的，因为接口隔离了实现类内部的倪安东。这类的方法（返回一个接口引用）不是一个普通意义上提供直接操作字段功能的“getter”方法。如果你改变了提供者的内部实现，你只要改变返回对象的定义就能适应这些变化。你依然保护了那些通过对象接口来访问的外部代码。</p>\n<p>　　其次，我认为所有的OO系统都有一个面向过程分界层。绝大多数OO程序运行在面向过程的操作系统只上并且与面向过程的数据库通讯。这些外部过程化子系统的接口是通用性质的。Java Database Connectivity(JDBC)设计者并不知道你为何目的使用数据库，所以数据库类必须设计的通用和高度灵活。一般来说，不必要的灵活性是有害的，但是对于这些API来说过度的灵活性是不可避免的。这些边界类被简单的使用存储方法加载因为设计者别无选择。</p>\n<p>　　事实上，设计者不知道用户如何调用的问题充斥着整个Java包。如果你不能预测你将如何使用类对象那么淘汰所有存储器就是困难的。受制于此，Java设计者已经做了一切他们能做的去隐藏实现。这并不是说你的代码也应该采用jdbc的设计风格。绝不应该！我们一定知道我们的类是如何被使用的，所以我们不用浪费时间去创建不必要的灵活性。</p>\n<h2 id=\"一个设计策略\"><a href=\"#一个设计策略\" class=\"headerlink\" title=\"一个设计策略\"></a>一个设计策略</h2><p>　　 所以我们怎么抛弃getter和setter呢？</p>\n<p>　　 以用例为中心的OO设计过程:用户执行的有输出结果的特定任务。（登录不是一个用例因为它在问题域中缺少有用的结果输出。所以绘制一个账单是一个用例。）一个面向对象的系统实现了创建包含用例的各种场景所需的活动。实现用例的运行时对象通过向另一个对象发送消息来完成工作。当然，不是所有的消息都是等价的。如果你只是简单的构建了一个使用对象和类的面向过程的程序，那么你就不很难完成所有工作。</p>\n<p>　　1989年，Kent Beck 和 Ward Cunningharn在教授面向对象的设计课程时，曾对改变过度依赖get/set的心理做了如下的阐述：</p>\n<pre><code>在教授面向对象的程序设计时最困难的是让学习者放弃那些在面向过程程序中司空见惯的全局信息获取，转而依赖类本身的信息去完成他们的任务。新手的设计充斥着全局思维：非理由的全局变量、不必要的指针以及在实现过程中对其他类不恰当的依赖。\n</code></pre><p>　　Cunningham发展了一套能够很好展示设计过程的教学方法:CRC卡片（类，职责，协作）。最基本的做法是做一套4x6规格的索引卡片，用来展示三个方面：</p>\n<ul>\n<li>类：类对象的名字</li>\n<li>职责：那些类可以做什么。这些职责应该专注于一个特定技术范围内</li>\n<li>协作：可与当前类对象通讯的其他类对象。这里的东西越少越好</li>\n</ul>\n<p>　　CRC卡片最初的构想是基于一个假设——事情总会发生变化。</p>\n<p>　　Beck和Cunningham然后挑选一个用例，然后决定哪些对象会被要求执行这个用例做出最全面的假设。他们通常从两个类开始着手，不断的添加其他类用以实现用例。他们从班上挑选一些人来代表那些对象并发给他们一张相关的CRC卡片。如果他们需要一些给定的类对象，那么一些学生会被挑选来代表那些对象。</p>\n<p>　　然后这个班级开始根据以下规则实现用例：</p>\n<ul>\n<li>通过与其他人的沟通来完成用例包含的动作。</li>\n<li>你只能与你的协作对象进行交流。如果你必须和其他人交流，你应该交由一个能与那人交流的协作对象去完成，如果依然不行，你必须在你的CRC卡片上添加一个协作这。</li>\n<li>你不能去直接获取用来完成工作的信息。取而代之的，你必须请求拥有这些信息的对象去完成这个工作。把完成任务必须的信息传递给协作者是可以的，但是请把这些互动保持在最低限度。</li>\n<li>如果一些事情必须完成但是又没人能完成，那么创建一个新类和CRC卡片或者在已有的类和CRC卡片中添加一个职责。</li>\n<li>如果卡片写的太满，你必须创建其他的类和CRC卡片去分担一些指着。类的复杂度被4x6卡片的容量所限制。<br>　　<br>　　整个交流的记录就是程序的动态模型。最终完成的CRC卡片就是静态模型。通过不断的尝试和实践你可以使用这个方法解决任何问题。</li>\n</ul>\n<p>　　我刚刚描述的这个过程就是面向对象设计过程，尽管为适应课堂教学做了简化。一些人使用CRC卡片设计真实的程序。然而，更多的时候，设计者使用统一建模语言（UML）设计动态和静态模型。OO系统的要点是对象的通讯。如果你仔细思考，get/set方法在通讯过程是不需要的。同样的，在你开始编码之前，如果你以这种方式设计，get / set方法将不会出现在你的代码中。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　　让我们总结一下：除非逼不得已你应该避免使用存储器因为这些方法暴露了类是如何实现的信息，从而导致你的代码变得难以维护。有时get/set方法不可避免，但是根据面向对象设计经验去掉你现在代码中99%的get/set方法是没有困难的。</p>\n<p>　　getter/setter方法往往会在代码中起到作用因为编写者使用过程思维来思考问题的，摆脱这种过程思维的最好方法是设想定义明确职责的对象之间的对话。Cunningham的CRC卡片方法是一个伟大的入门手段。</p>"}],"PostAsset":[{"_id":"source/_posts/hexo-install/helloworld.png","slug":"helloworld.png","post":"cj4tf869400006b6n2soqk5an","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj4tf869400006b6n2soqk5an","category_id":"cj4tf869c00046b6n71nko5xd","_id":"cj4tf869l000a6b6nkm1ooplp"},{"post_id":"cj4tf869900026b6nd2euot4d","category_id":"cj4tf869j00086b6nf55bi9tj","_id":"cj4tf869o000e6b6nddon72na"},{"post_id":"cj4tf869g00066b6nagyrw8ql","category_id":"cj4tf869j00086b6nf55bi9tj","_id":"cj4tf869p000h6b6nmxdhqybt"}],"PostTag":[{"post_id":"cj4tf869400006b6n2soqk5an","tag_id":"cj4tf869f00056b6nvye4lwno","_id":"cj4tf869o000d6b6n24uddmbb"},{"post_id":"cj4tf869400006b6n2soqk5an","tag_id":"cj4tf869k00096b6ngja85bdg","_id":"cj4tf869o000f6b6nfgdbjply"},{"post_id":"cj4tf869900026b6nd2euot4d","tag_id":"cj4tf869l000c6b6ne4os1m66","_id":"cj4tf869q000k6b6n4hcxqcq9"},{"post_id":"cj4tf869900026b6nd2euot4d","tag_id":"cj4tf869o000g6b6nprcwe4ql","_id":"cj4tf869r000l6b6n6lxpb8d8"},{"post_id":"cj4tf869900026b6nd2euot4d","tag_id":"cj4tf869p000i6b6nxfkcrgem","_id":"cj4tf869s000n6b6nku81ec95"},{"post_id":"cj4tf869g00066b6nagyrw8ql","tag_id":"cj4tf869l000c6b6ne4os1m66","_id":"cj4tf869u000r6b6nalemkfpu"},{"post_id":"cj4tf869g00066b6nagyrw8ql","tag_id":"cj4tf869p000i6b6nxfkcrgem","_id":"cj4tf869v000s6b6n1rnpxgqq"},{"post_id":"cj4tf869g00066b6nagyrw8ql","tag_id":"cj4tf869s000o6b6n4a1w73ps","_id":"cj4tf869v000t6b6nsqss1zij"},{"post_id":"cj4tf869g00066b6nagyrw8ql","tag_id":"cj4tf869s000p6b6nlr23bx3g","_id":"cj4tf869v000u6b6nmuptaaoh"},{"post_id":"cj4tf869g00066b6nagyrw8ql","tag_id":"cj4tf869t000q6b6nxvvwu2l3","_id":"cj4tf869v000v6b6nrzccekwc"}],"Tag":[{"name":"hexo","_id":"cj4tf869f00056b6nvye4lwno"},{"name":"安装","_id":"cj4tf869k00096b6ngja85bdg"},{"name":"Java","_id":"cj4tf869l000c6b6ne4os1m66"},{"name":"继承","_id":"cj4tf869o000g6b6nprcwe4ql"},{"name":"翻译","_id":"cj4tf869p000i6b6nxfkcrgem"},{"name":"存储器","_id":"cj4tf869s000o6b6n4a1w73ps"},{"name":"getter","_id":"cj4tf869s000p6b6nlr23bx3g"},{"name":"setter","_id":"cj4tf869t000q6b6nxvvwu2l3"}]}}